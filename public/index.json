
[{"content":"\r壹\r#\rp@2睁圆了眼，从沾满水渍的镜子里视察崭新的瓷牙，不由得飘飘然，心满意足地拍着愈发饱满的肚皮，生出些天生我材的感慨。\n再裹上西装制服，p@2平庸的容貌也在镜子里衬得富有层次。稍整红领带后装模作样摆些动作\u0026mdash;\u0026mdash;\u0026mdash;无外乎眯眼、板脸、背手之类\u0026mdash;\u0026mdash;\u0026mdash;p@2快意于拿捏住经理气质的精髓。\n一个月前，p@2自是想不到他竟能因在互联贴上同公司高层对骂，从门前的保安一跃晋升到公关部经理。但待事情过去得稍久，他琢磨几番，决心乘势做些包装，宣称这是有预谋地展现天赋，以谋求晋升。\n在p@2的叙述里，他摇身一变，成了善于把握机会且大胆的天才，而公司某高层也沾上不拘一格的光彩。p@2的宣称仅激起少许水花，却如病毒般蔓延，流入员工的耳朵。\n作为自由城规模最大的集团公司之一，公司里的员工混杂着各式群体。有些狂热主义的，对此言语间赞颂之词连绵不绝；有利己主义的，不见得相信，却也觉得称赞经理或许可以得点好处。还有些社达主义的，无甚所谓，自认过段时间就会把p@2踩在脚下；再有臆想主义的，八卦起p@2和高层的关系，找出了这样那样的证据\u0026hellip;\u0026hellip;\n而有一类人，对p@2的宣称和他的晋升嗤之以鼻，以为他那样的家伙能当上公司的经理，只是纯粹的走大运。他们大多都是p@2曾经的熟识，见过p@2那副长着烂牙的真面孔。\n贰\r#\rp@2的门牙一度都只剩下半颗，断裂的另外半颗，要归咎于冰冷的水泥地。在某个休假的下午，他骑着自行车从公司回家去。 自由城的雾霾一如既往很重，但幸运获得休假的他心情极好，觉得明媚的阳光弥散着鲜香。尤其当他经过顾客络绎的酒楼，听到如缕不绝的喘息声时，更是莫名的高兴。 他双手撒开车把，哼起不着调的曲，高大的身体像蛆虫一样扭动，好似很潇洒。但没多久，p@2便在车轮碾过石头往前时失去平衡，脸朝地面摔在了酒楼前。血液涓涓流出，他引以为豪的洁净门牙断成两截，一半留在牙床上，另一半扎进水泥地。\n迎着看热闹的目光，p@2只好难堪地捂住嘴，把水泥地里的牙拔出来揣进兜，骑上已经变形的自行车逃离现场。\n回到家后，p@2检查手中和镜子里脸上的断牙，一阵懊丧。对于一名保安来说，洁净的门牙是他的招牌，是保安评级最重要的指标。倘若失去了洁净的门牙，他几乎失去了这份来之不易的工作。毕竟，保安工作的重中之重，便是每日向高层问好\u0026mdash;\u0026mdash;\u0026mdash;在公司的高层跨过大门进入公司时，先露出牙齿微笑，再鞠躬120度。而在此之前，p@2依靠着他洁净无缺的门牙和韧性十足的脊椎，常在保安评级中拿到优秀。\n其实断裂的门牙并非没有补救的办法，只需花0.1自由币在互联引擎里搜索相关的服务，就可以找到一批愿上门修牙的医生，但一月薪水仅100自由币的p@2显然负担不起：一次修牙至少需要800自由币，以门牙从中断裂的程度，他至少要修三次牙。\n负担不起费用，p@2只好对着互联引擎界面上的广告发愁，他心说绝不能再一次失去工作。自由城的工作岗位向来竞争激烈、难以获得，不少女性为了获得一份工作，甚至会做手术切除子宫，以图在人事部门眼中有更高的竞争力。而p@2上一次失去工作，有一整子足足饿了十天，饿到眼前发昏和狗抢食物吃。\n最终p@2在长久的沉默中想到了办法。他花1自由币购买了一支502胶水，将断掉的门牙黏上，留有缝隙的地方就用石头碎末蘸胶水一点点补齐、磨平。久了以后，断裂的地方总被氧化成黑色，于是p@2又常备一罐白漆和一瓶口腔清新剂，用白漆遮盖黑迹，又用清新剂驱散白漆味。\np@2用不到20自由币就解决了断牙的问题，保住了工作，于是有点得意的情绪。他不免向熟人吹嘘一番，说自己用20自由币赚走了医生的2400自由币。\n叁\r#\r照p@2的熟识所言，p@2极其热衷于发表一些\u0026quot;高见\u0026quot;或\u0026quot;妙法\u0026quot;，它们不一定确凿的高明、巧妙，却异于常人而颇具特色。\n譬如自由城的姓名制度，由自然生育或出生后有家室背景的，以姓与氏的组合由长辈命名；而由生育工厂生育且无收养人的，以字符串形式待成人后自由命名。\n寻常的人，有地位的获利者往往赞赏制度，以为区隔了贵族气质和平民；没有地位的往往哀叹，或是愤怒；再还有些游离的走狗，昧著心替贵族主人狂吠。但p@2的论调独树一帜，他分外赞赏自由城的欣赏姓名制度，称其为平民百姓提供了自由表达个性的权利，并且依此认为自己比那群连名字都让长辈起的贵族更高贵。\n再譬如他曾经掌握了一种快速解决经济燃煤之急的方法。在那个已经十天未进食后饥饿难耐的夜里，不断靠近又远去的幻觉让他想明白，一个人身上最值钱的东西，除去长期的劳动力，就属身体本身了。\np@2决计赚些差价，出卖一个器官可以获得3500自由币，而一个廉价的非军用义体，往往才1500自由币不到，哪怕扣除些手术费，他最终都可以拿到1500自由币，唯一的弊端是他必须得常备几支5自由币的镇静药\u0026mdash;\u0026mdash;\u0026mdash;人体极容易排斥廉价的义体。自此以后，p@2很长一段时间都不愁衣食，直到他身上除健康不达标和不可替换的器官外，全都变成了金属材料，他恍然惊醒不得以寻找一份工作。\n以这些\u0026quot;高见\u0026quot;和\u0026quot;妙法\u0026quot;为基础，本没什么兴趣天赋的p@2拥有了爱好。每日近十二点下班回家后，他总会一边吃上一份0.5自由币的夜宵，一边打开互联贴花费0.5自由币发言水帖，留下诸个\u0026quot;高见\u0026quot;和\u0026quot;妙法\u0026quot;，然后同底下的留言争论不休。\n倘若底下的留言是反驳，p@2必然是人身攻击辅以阴阳怪气伺候；而若是认同，则须看p@2的心情，心情不好，就常有类似\u0026quot;不会吧，我瞎说的你都信，真不愧是我的狗。\u0026ldquo;的回复。\n肆\r#\r照理说，在互联贴里的叫嚷的p@2，与在公司门口低头鞠躬的他本不该关联，但他终究是惹了麻烦。某晚同他对骂的家伙，恰是公司的高层，骂的本事不及他，却直接动用关系查到了p@2本人。因此电话铃声径直从p@2屋内响起，森冷年轻的声音从电话的另头传来。第二日到对方办公室的命令直愣愣的撞进p@2的脑海，让他无意识地跪在了地上。\n待第二日p@2麻木地签下卖身契，成为公司公关部门的经理负责公司舆论后，他才从茫然中醒来，深感这完全是天大的良机，既不愁衣食，又可寻油水。p@2又是流泪又是磕头地感谢对方的再造之恩。\n伍\r#\r于是p@2的熟识总说，公司某高层身边，总有一条亦步亦趋的狗。\nps.读《阿Q正传》有感\n","date":"2025年12月6日","externalUrl":null,"permalink":"/create/novel/%E6%99%8B%E5%8D%87/","section":"创作","summary":"","title":"晋升","type":"create"},{"content":"语言组成\r#\r字符集\r#\r英文字母\r数字字符\r特殊字符\r词法记号\r#\r关键字\r标识符（函数名，变量名，类名，对象名等）\r字母或下划线开始\r可以由字母、下划线和数字组成\r区分大小写\r不能与语言关键字或操作冲突\r文字\r操作符（运算符）\r分隔符（\u0026quot;（）\u0026quot;\u0026quot;{}\u0026quot;\u0026quot;，\u0026quot;\u0026quot;：\u0026quot;\u0026quot;；\u0026quot;）\r空白（空格、制表符、换行符、回车符，注释）\r数据类型\r#\r整型\r#\rshort 2byte\rint 4byte\rlong 8byte\r浮点型\r#\rfloat 4byte\rdouble 8byte\r字符型\r#\rchar 1byte\r布尔型\r#\rbool 1btye\r类型转化\r#\r隐式转化\r逻辑运算 非零数据转化为true，零转化为false\r算术运算\r赋值运算\r显式转化\r（类型说明符）表达式\r四种类型转化操作符\rconst_cast\\\u0026lt;类型\\\u0026gt;（表达式）\rdynamic_cast\\\u0026lt;类型\\\u0026gt;（表达式）\rreinterpret_cast\\\u0026lt;类型\\\u0026gt;（表达式）\rstatic_cast\\\u0026lt;类型\\\u0026gt;（表达式）\r类型别名和推断\r#\r类型别名\r#\r类型声明\rtypedef 已有类型 新类型（将标识符声明成某数据类型）\r别名声明\rusing 新类型=已有类型（一次只能声明一个别名）\r类型判断\r#\rauto类型\r让编译器替我们分析类型 定义时必须有初始值\r同样可以一次定义多个变量，但是变量间需类型一致\rdecltype类型\rdecltype（i）j 可以无需初始值，表达j与i类型一致\r常量与变量\r#\r字面常量\r#\r整型常量（八进制以0开头，十六进制以0x开头）\r后缀u表示unsigned 类型\r实型常量\r一般形式\r指数形式 e后数表示十的次方数\r字符常量\r单引号括起来\rASCII码\r字符串常量\r每个字符占一节，在末尾添加\\\\0作为标记\r布尔常量\rfalse 和 true\r变量\r#\r变量声明 类型+名称\r变量初始化\r非列表初始化 \u0026quot;=\u0026quot;\u0026quot;（）\u0026quot;\r列表初始化 \u0026quot;{}\u0026quot;\u0026quot;={}\u0026quot;（不允许数据丢失）\r变量储存类型\rregister 寄存器\rextern 所有函数和程序段中使用\rstatic 固定地址存放，整个运行期间有效\rthread_local 具有线程存储生存期\r修饰命名空间、块作用域中变量\r以及被指定为static存储类型的变量\rmutable 只作用于类数据成员\r符号常量\r#\r声明的同时初始化 const 类型 变量名=常量值\r程序中间不可改变其值\rconstexpr关键字 验证是否为常量表达式，暗含const属性\r运算符（与表达式）\r#\r运算符\r#\r算术运算符 \u0026quot;+\u0026quot;\u0026quot;-\u0026quot;\u0026quot;\\*\u0026quot;\u0026quot;/\u0026quot;\u0026quot;%\u0026quot;\u0026quot;++\u0026quot;\u0026quot;\\--\u0026quot;\r赋值运算符 \u0026quot;=\u0026quot;\u0026quot;（基础算术运算符或位运算符）=\u0026quot;\r逗号运算符 表达先后顺序\r关系运算符\r大小关系 \u0026quot;\\\u0026lt;\u0026quot;\u0026quot;=\u0026quot;\u0026quot;\\\u0026gt;\u0026quot;（高）\r等于关系 \u0026quot;==\u0026quot;\u0026quot;！=\u0026quot;（低）\r逻辑运算符\r\u0026quot;！（非）\u0026quot;\u0026quot;\u0026amp;\u0026amp;与\u0026quot;\u0026quot;\\|\\|或\u0026quot;（与和或有短路效应）\r（高 --------------------------- 低）\r条件运算符 实现选择功能 布尔类型表达式？表达式1：表达式2\rsizeof运算符 计算某种类型对象占据的byte\r位运算符\r按位与(\u0026amp;) 按每一位做与运算\r按位或(\\|) 按每一位做或运算\r按位异或(\\^) 按每一位做异或运算\r按位取反(\\~) 按每一位做非运算\r移位 左移（\\\u0026lt;\\\u0026lt;） 右移（\\\u0026gt;\\\u0026gt;）\r运算符优先级\r操作数\r#\r表达式中，一个操作的输入值\r算元\r#\r所需要的操作数的数目\r数据的输出与输入\r#\rI/O流 数据从一个对象到另一个对象是流，输入输出流\n插入符与提取符\r#\r\\\u0026lt;\\\u0026lt; 插入符 输出数据\r\\\u0026gt;\\\u0026gt; 提取符 输入数据\r简单的I/O控制\r#\r常用操作符\r算法的基本控制结构\r#\r顺序结构\r#\r选择结构\r#\rif语句\rif-else if语句后代码块语句有多个代码语句时\rif-else if-else（嵌套结构在else分支中）（本质是语法糖）\rswitch语句\rswitch-case（break）-default\r循环结构\r#\rwhile语句\rwhile\rdo-while（至少执行一次循环体语句）\rfor 语句\rfor（初始值;循环控制;变量改变）\r范围for语句 for(声明：变量)\rbreak语句\r从循环跳出\rcontinue语句\r结束本次循环开始下一次\rgoto语句\r#\r跳转到标识符\r","date":"2025年11月24日","externalUrl":null,"permalink":"/note/cpp/1.%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/","section":"笔记","summary":"","title":"1.设计基础","type":"note"},{"content":" 高精度计算(High-Precision Calculation)通过自定义存储和模拟手工运算实现计算\r核心问题\r#\r常规数据类型的范围有限,处理更大的数时，常规类型会发生溢出\r数据存储方式\r#\r高精度计算的核心是用字符串或数组存储大整数,两种方式各有优势\r-----------------------------------------------------------------------\r存储方式 优势 适用场景\r字符串 直接输入，便于输出 输入输出频繁、需直接处理字符的场景\r动态数组 访问效率高，便于运算 运算密集型场景（如乘法、除法）\r------------------------------------------------------------------------\r存储细节\r#\r顺序 通常按低位在前，高位在后存储，方便从低位开始处理进位/借位；\r正负号 用单独的标志位存储符号，数值部分仅存绝对值\r前导零 存储时需去除前导零，避免运算错误。\r核心运算实现（以非负整数为例）\r#\r高精度加法(A+B)\r#\r核心逻辑 从低位到高位逐位相加，累加进位，最终合并结果。\r步骤\r反转A和B（使低位在前）\r初始化进位carry=0，遍历两数的每一位\r当前位总和 = A[i]的数值 + B[i]的数值 + carry\r结果当前位 = 总和 % 10\r新进位 = 总和 / 10\r遍历结束后，若仍有进位(carry\u0026gt;0)，将进位添加到结果\r反转结果，得到最终答案\r高精度减法（A-B，需A\u0026gt;=B）\r#\r核心逻辑 从低位到高位逐位相减，处理借位(若当前位A[i]\u0026lt;B[i]，则借位)\r步骤\r先判断A≥B（位数多则大；位数相同则逐位比较）\r反转A和B，初始化借位borrow = 0，遍历每一位\r当前位A[i]的数值 = 原数值 - borrow（减去上一位的借位）\r若A[i]\u0026lt;B[i]，则A[i]+=10，同时borrow=1（向高位借位）\r结果当前位=A[i]-B[i]\r反转结果，去除前导零。\r高精度乘法（A*B）\r#\r核心逻辑 逐位相乘后累加，利用数组存储中间结果，最后处理进位。\r步骤\r若A或B为\u0026quot;0\u0026quot;，直接返回\u0026quot;0\u0026quot;\r初始化结果数组resArr(长度为A.size()+B.size())\r遍历A的每一位和B的每一位（从低位到高位）\r乘积 = A[i]的数值*B[j]的数值\r累加至resArr[i+j+1](当前位),并将进位累加到resArr[i+j]\r处理数组中的进位（每一位超过 10 则向高位进位）\r将数组转换为字符串，去除前导零。\r高精度除法（A/B）\r#\r高精度除法分两种场景，实现难度差异较大：\r---------------------------------------------------\r场景 难度 核心逻辑\r高精度/低精度 简单 从高到低逐位试商，保留余数\r高精度/高精度 复杂 用减法模拟除法或二分法\r----------------------------------------------------\r处理正负号\r#\r上述运算仅支持非负整数，若需处理负数，需增加符号逻辑\r用标志位（如bool negA = (a[0] == '-')）记录A和B的符号\r提取绝对值部分（如a = a.substr(1)）进行运算\r根据符号和运算类型确定结果符号\r","date":"2025年11月24日","externalUrl":null,"permalink":"/note/datastructandalgorithm/%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%AE%A1%E7%AE%97.docx/","section":"笔记","summary":"","title":"高精度计算","type":"note"},{"content":"\r壹\r#\r离开果木香馥郁的家族府邸，埃尔维斯顾不得汗水淌过形成皱褶而崎岖的皮肤，踩着咯吱作响的自行车回到自己的别墅。\n埃尔维斯沐浴在迷幻的氛围灯下，褪下被浸湿成深色的衣裤，换上与窗外微亮弯月相吻合的睡服。在公文包里摸索一番，他顺利地拿出了惯常使用的硬壳笔记本，然后便坐在了互联电视前。\n埃尔维斯夫人在房间的软塌上欣赏着市面上新近流行的小说，无所遗漏地听见门锁转动的咔哒声、脱衣与穿衣的窸窣声、电视节目中女偶像的清冽歌声。例证时间的流逝而不曾暗淡的紫瞳，依旧停留在纸面的故事，然而埃尔维斯夫人再也难以集中注意力。\n尽管具体的时刻于记忆边缘处滑落，埃尔维斯夫人大体清楚，这两个月来，自己年过六旬的教授丈夫，每天都定点收看娱乐公司最新推出的女偶像的节目，而且没有半分令人心安的解释。\n过去的两个月里，她对丈夫温和性格和良好声誉，以及多年共度的爱情，保持着充分的信任。但长时间缺乏有效且深入的沟通，她终于决定打破她固有的矜持，同丈夫聊一聊这件以足以影响未来的事。\n迷幻得暧昧的灯光打在埃尔维斯夫人的素衣，缓步走动的母狮般矫健的身躯被衬得更加年轻。她用尽可能柔和的沙哑声音向埃尔丈夫发问。\n\u0026ldquo;亲爱的埃尔维斯，是萨尼亚逃窜而来的魔鬼，唤起了你的年轻心态吗？\u0026rdquo;\n沉着的视线从容地从电视收回，循着声音落在了埃尔维斯夫人的脸庞，银白头发被灯光染成酒红。\n\u0026ldquo;年轻的心态？我没有明白你的意思，莲。不妨说得直截一些。\u0026rdquo;\n\u0026ldquo;如果你不介意的话\u0026mdash;\u0026mdash;\u0026mdash;我不认为六十岁的老人成为人为塑造的女偶像的粉丝，会是一件体面的事情。\u0026rdquo;\n\u0026ldquo;人为塑造？你是说\u0026mdash;\u0026mdash;\u0026mdash;\u0026rdquo;\n\u0026ldquo;没错，女偶像的背后是最专业的编剧团队，编纂出一个个勾人的故事。我的父亲是娱乐公司的股东，我自己还是娱乐公司的会计，我是具有发言权的。\u0026rdquo;\n\u0026ldquo;这是我没能观察到的，这个事实会成为我的研究重要的补充材料。\u0026rdquo;\n边说着，埃尔维斯边向夫人展示了他的笔记本，上面记满了他对偶像的观察结果和相关联想。他解释道这是一个全新的社会学课题，此前还没有学者关注。\n埃尔维斯夫人欣然接受丈夫的解释，为一场可能的危机被高效地消解而心情愉悦，并想起来这之外的另件要事。\n\u0026ldquo;埃尔维斯，你受召回家族府邸是要商议什么重要的事吗？\u0026rdquo;\n\u0026ldquo;不是什么大事，族里准备把三叔的孙子推上台，通知一下其他几脉。我下午见到了那个年轻人，他把自己整饬得很体面，履历也很漂亮。\u0026rdquo;\n\u0026ldquo;所以你要为你的亲侄子做点什么吗？\u0026rdquo;\n\u0026ldquo;那倒不用，主要是四叔和五叔两脉帮忙，其他几脉往后才有其他安排。\u0026rdquo;\n\u0026ldquo;那挺好，我认为你还是更适合安心教书和做学问。\u0026rdquo;\n互道晚安之后，电视中的女偶像继续站在舞台中央歌唱，而埃尔维斯夫人终于安心地在软塌上享受和风柔水似的文字。\n贰\r#\r日光透过灰蒙的云勉强的洒在自由城的各个角落，娱乐公司精致的金蚂蚁商标因此显得暗淡无光。但谈不上美妙的天气，目前还没有影响到埃尔维斯的心情。\n课题陷入到瓶颈已经有一段时间了，埃尔维斯不得不询问夫人，是否能借助她父亲的身份获得与女偶像面对面交流的机会，获得了肯定的回复。\n\u0026ldquo;你应该很清楚公司为她打造的性格卖点，一个思想深刻、学识丰富，并且能向大众输出个人观点的女偶像。而让她和一位货真价实的教授当面交流，宣传得好是极有利于巩固形象的。\u0026rdquo;\n于是埃尔维斯和妻子踏上灿金色地砖，一路穿过大厅和曲折过道，又乘电梯来到四楼，再度路过几处两旁裱有名画仿品的长廊，终于来到了女偶像的面前。莲在将丈夫送到后便回到了自己的办公室，两个小时的时间被留给埃尔维斯和女偶像。\n女偶像留有一头乌黑秀发，柔软富有韧性的身段呈现出礼貌而不失疏离的气质。那双宝石般璀璨的蓝眼睛深邃而神秘，隐约散发着对埃尔维斯的陌生与好奇，几乎让埃尔维斯为之晃神。\n两个小时的时间足以让一个经验老道的采访者深入地了解眼前的人，并获得自己需要的内容。挂钟指针缓慢腾挪的机械音中，埃尔维斯认识到女偶像心目中的理想生活，她对自己和娱乐行业的看法。\n她的嗓音一如歌声清冽，从容恰当地表露出自己内心世界的一角，偶有的停顿也丝毫不影响她理性的倾吐。埃尔维斯从中仿佛看到了一个智慧的女性。\n两小时的最后，埃尔维斯站起身来，克制地看向那张让无数自由城青年魂牵梦绕的脸，笑着说道：\n\u0026ldquo;我有个学生，和你在很多地方有相同的见解，你们俩甚至长得也挺像的，不过她比你要更冒失一些，她梦想是当一名老师。\u0026rdquo;\n\u0026ldquo;如果这是真的话，那我很想见见她，说不定她是我失散的妹妹或姐姐，就像一些无厘头电视剧里演的那样。\u0026ldquo;女偶像半开着玩笑回复了教授。\n试图把握着对娱乐行业更深层次的认知，灰蒙的天气终于让他感到一些莫名的沮丧。他独自离开自由城唯一的娱乐公司，走之前看到了三两熟悉的面孔，是他亲侄子的管家和助理。\n待蒙上雾纱的月又一次夜幕里显现，别墅的门响起标识莲回家的咔哒声。在这个女偶像没有节目播出的夜晚，埃尔维斯和妻子交流起他今天的感受。\n\u0026ldquo;今天那位女偶像给我的感觉很真实，那些想法不像是编剧灌输给她的，况且我没有看到她与编剧沟通的工具。\u0026rdquo;\n埃尔维斯夫人摇摇头。\n\u0026ldquo;你太小瞧编剧团队的专业性了，他们得知她要和你面对面交谈，一定会详细地调查你的学术背景，依此做好充分的预案，你是第一次采访，但人家却可能排练了几十遍了。\u0026rdquo;\n埃尔维斯不可置否，他转而问起他亲侄子的管家和助理。\n\u0026ldquo;你侄子不是马上要参与大选吗？家族好像很早就有动作，前几年就找到公司说要希望为你侄子造势，今天应该是来续合同确认最终合作的。\u0026rdquo;\n\u0026ldquo;娱乐公司怎么替我侄子造势？\u0026rdquo;\n\u0026ldquo;听说准备让那位你侄子明面上和那位女偶像谈感情，让女偶像带动她庞大的粉丝成为你侄子的选票。她那思想深刻的人物形象，应该就是专门为这个目的打造的。\u0026rdquo;\n埃尔维斯沉默半响，点燃了一根不常拿出的香烟，白烟在迷幻中升腾、模糊，最终消散。\n叁\r#\r坐在古式且古色的木椅上，接过侄子管家恭敬地递来的茶水抿上一口，埃尔维斯的思绪随若有若无的朽木腐臭飘得很远。\n他在侄子诺大的办公地里来来回回的清洁女仆中看到了一个熟悉的身影，有着一头黑发和蒙了雾的蓝眼睛。他动身向围了围裙拿着扫把的女人走去。\n\u0026ldquo;您好先生，有什么能帮到你的吗？\u0026rdquo;\n\u0026ldquo;我想我们曾经见过的，你不记得了吗。\u0026rdquo;\n女人疑惑地看向埃尔维斯。\n\u0026ldquo;对不起，老先生。您准是认错了，我自小生活在农村，后来幸运地被老爷雇佣。平时没有见过什么人，更何况您呢。\u0026rdquo;\n\u0026ldquo;这样啊，那可能是我看错了，你和我认识的一个人长得很像，很抱歉打扰到你。\u0026rdquo;\n重新坐在木椅上的埃尔维斯抚着公文包的皮扣，有些浑浊的眼睛少许地失去焦距。他问旁边挺直着站立的管家：\n\u0026ldquo;我记得那是曾经红火，嫁给文森特后退役的女偶像。\u0026rdquo;\n\u0026ldquo;大众的确是这么认为的，老爷。事实上，她只是娱乐公司的一件商品，是家族为给文森特少爷造势专门定制的。本来等她发挥出应有的价值应该销毁的，但少爷心善，把她送到娱乐公司做了些微调就留下了。\u0026rdquo;\n埃尔维斯还想再问，但文森特的助理径直地走向他，并告知他议会和研究院的谈判正处于胶着状态，一时半会走不开。\n\u0026ldquo;议会长先生说，如果您有要事可以先和我沟通，待议会长先生空闲下来，我在转告给他。\u0026rdquo;\n埃尔维斯想了想，最终叹出一口浊气。\n\u0026ldquo;没什么大事，只是一些关于娱乐行业的看法和政策建议，改日我再找议会长就行。\u0026rdquo;\n埃尔维斯回到家时异乎寻常的阴沉脸色，让正享受休息日的夫人吓得不轻，连忙询问缘由。\n埃尔维斯又点起了香烟。\n\u0026ldquo;莲，你和你父亲\u0026hellip;知道娱乐公司做着记忆篡改的生意吗？\u0026hellip;\u0026rdquo;\n日光铺在埃尔维斯夫人的银发上，骤然收缩的瞳孔以及起伏的胸口，让夫人险些失去往日的优雅与淡定，出离惊慌后是不止的愤怒。\n\u0026ldquo;记忆篡改？那可是犯罪的勾当！你是说，那些女偶像的记忆被篡改了，所以人物形象才如此真实？\u0026rdquo;\n缓和一会，夫人冷静快速地做出了决断。\n\u0026ldquo;埃尔维斯，如果你确认自己的结论的话，我们要去报警。\u0026rdquo;\n埃尔维斯猛的吸一口香烟，被呛到后痛苦地闭上了眼，又摇摇头。\n\u0026ldquo;几年前，我教过一个满怀热情的女学生，她后来\u0026hellip;成了为自由城议会长拉票的女偶像，再后来\u0026hellip;她成了一个出身乡下的女仆负责打扫卫生\u0026hellip;\u0026rdquo;\n\u0026ldquo;唉\u0026hellip;\u0026rdquo;\n","date":"2025年12月6日","externalUrl":null,"permalink":"/create/novel/%E5%81%B6%E5%83%8F/","section":"创作","summary":"","title":"偶像","type":"create"},{"content":"函数的定义与使用\r#\r函数定义\r#\r返回值类型 函数名(形式参数){\r具体运算代码块；\rreturn 返回值;}\r函数调用（函数的调用应该在声明或具体定义之后）\r#\r嵌套调用\r递归调用\r直接或者间接的调用自身\r递推+回归\r函数参数传递\r#\r值传递\r将实参的值传递给形参\r函数内对形参操作不改变实参本身\r引用传递\r给实参起一个别名，引用给形参\r声明引用必须初始化指向已存在对象\r引用的底层实现是指针\r默认参数传递\r在声明形参类型时初始化\r若无相应实参传入则为默认值\r可变形参传递\r实参类型相同\r通过标准库类型initializer_list\\\u0026lt;type\\\u0026gt; list 生成一个列表对象\rinitializer_list类提供的操作（服务）\rsize( )元素数量\rbegin( )返回首元素指针\rend( )返回尾元素下一位置指针\r以序列{}形式传入实参\r实参类型不同\r可变参数模板\r内联函数（结构简单，语句少，调用频繁）\r#\r编译期间将函数体嵌入调用处\r避免函数调用的栈帧开销（参数压栈、跳转、返回等）\r*语法形式 inline + 函数定义\rconstexpr函数\r#\r让编译器在编译阶段完成计算、内存分配操作，提升程序效率\r用于常量表达式的函数，返回值、形式参数必须都为常量\r*必须有且仅有一条return语句\r函数重载\r#\r函数名相同但形参个数/类型不同（无论返回值），编译器自动确定调用哪一个函数\r*使用默认形参值的函数重载时注意防止二义性\rvoid fun (int a,int b=0);\rvoid fun (int a);\r系统函数\r#\r标准cpp函数（更强可移植性）\r当前操作系统或编译环境中特有的\r\u0026lt;cmath\u0026gt; sqrt,abs(绝对值),sin,cos,tan\\...\r","date":"2025年11月24日","externalUrl":null,"permalink":"/note/cpp/2.%E5%87%BD%E6%95%B0/","section":"笔记","summary":"","title":"2.函数","type":"note"},{"content":"基本法则\r#\r基准情形\r#\r有某些基准的情形，不需要递归就能求解\r不断推进\r#\r递归调用总能朝着产生基准情形的方向推进\r设计法则\r#\r假设所有递归调用都能运行，不必知道簿记管理的细节\r合成效益法则\r#\r求解一个问题的同一实例，切勿在不同递归调用做重复性工作\r书写方式（准确性待商榷）\r#\r确定递归的基准情形（也即递推的尽头和回归的开始）\r将问题分解为低一规模问题（找到演进方式）\r假设函数能实现低一规模问题，调用函数解决高规模问题\r复杂的递归问题\r#\r汉诺塔\r#\r借助终点柱，将高度为height-1的一叠盘子移到中间柱子\r将最后一个盘子移到终点柱子\r借助起点柱子将高度为height-1的一叠盘子从中间柱子移到终点柱子\r探索迷宫\r#\rDFS（深度优先）\r起始位置开始首先向北移动一格，在新位置递归重复\r第一步向北行不通，尝试向南移动一格，递归重复\r向南也行不通，就尝试向西移动一格，递归重复\r如果向北、南、西都不行，就尝试向东移动一格，递归重复\r四个方向都不行，意味没有出路\r（为避免陷入循环，已经探索过的位置不再探索）\r找零问题\r#\r贪婪算法\r尽可能用面值大的硬币\r递归算法\r基准情形：找的零钱金额与硬币面值相同，只需要1枚硬币\r不断推进：减去1枚硬币后比较大小选择\r记忆化\r基础的递归算法有大量重复性计算与法则第四条违背\r将已经计算的找零数目储存，在递归中进行查询\r动态规划\r从1分找零开始，系统地计算到所需的找零金额\r是一种有比较的递推算法\r","date":"2025年11月24日","externalUrl":null,"permalink":"/note/datastructandalgorithm/%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95.docx/","section":"笔记","summary":"","title":"递归算法","type":"note"},{"content":" 黑暗随流水声的响起逐渐褪去，灰蒙着不见云的天阴晦着映入眼帘，我迷茫地自混沌作无意识的昏睡中苏醒，擦去沉重水汽扑往鼻尖凝结成的露。当我艰难地从绵软的草地站起，支撑躯体的手无可避免地沾染上黑泥，而我恍然发觉自己不知何时穿上了朴质的乌衣，于是随意地把泥抹在了身上。\n我站在芳草之间，心绪因眼前水流湍急的江与江边徘徊的人而忐忑不宁。熟悉却陌生的莫名情绪无声积累，终于撬动了尘封记忆的一角。我认出了这里是蓝墨水的上游，这里是汨罗江。\n我不由得因兴奋而颤栗。透过古人深情的眼看得太多，我已然忘却了这个过程究竟有多少猜测、多少失真。或是历史，又或仅是无稽梦，但足以改正一切的江畔就在脚下，我想我没有理由拒绝。\n深陷草地的鞋携起黑泥四溅， 我径直走向江畔的诗人，挡住了他看不见尽头的去路。面容憔悴诗人年事已高，两鬓无几的白发引人联想起枯萎的兰。他不甚宽阔的肩因难以忽视的苦闷肿胀，魂魄飘渺的目光失了神采。\n\u0026ldquo;你是屈平。\u0026rdquo;\n\u0026ldquo;我是。\u0026rdquo;\n\u0026ldquo;你有投河的打算。\u0026rdquo;\n诗人并不惊讶我喊出了他的名字和意图，沉默地等着下文。我盯着他的眼睛，不禁笑出声了。\n\u0026ldquo;我听说过很多对你的称赞，专程为你而来，不如聊聊？\u0026rdquo;\n笑语尚未落地，诗人腰间的玉佩在摆动间铮鸣，清脆地同流水拍岸的巨响相和。我看见诗人寻回焦距的眼睛里满是愤怒。\n\u0026ldquo;你正在以轻浮的姿态污辱一个正直的人。\u0026ldquo;泠冽的语气令人心惊。\n\u0026ldquo;啊抱歉，我其实很想严肃的，只是散漫惯了，希望你能谅解。\u0026ldquo;边说着，我略感惊奇地摸到腰间的葫芦，我相信它是一壶酒。\n\u0026ldquo;来一点？\u0026rdquo;\n我问诗人。诗人不可置否。但最终黑泥在他一袭白衣上留下了些许痕迹，诗人端坐在了我的对面。于是我仰头望天，倒酒入喉，然后把葫芦递给诗人。酸涩的液体在喉咙里滚烫，莽撞地冲入胃肠肆意灼烧，我忍不住猛咳嗽。\n老态的诗人小股地将葫芦里的酒饮尽，没有错过我狼狈的样态，头一次向我发问。\n\u0026ldquo;你没有喝过酒。\u0026rdquo;\n\u0026ldquo;当然没有。酒只有两种人爱喝，快乐到能消解那股苦涩的，痛苦到压根对苦涩麻木的。我这类既不也不，只求过的潇洒的人一般哪有你的胆量喝酒。\u0026rdquo;\n诗人浑浊眼白中仍浑黑的眸子盯着我。\n\u0026ldquo;听你的口气，你对我很了解。\u0026rdquo;\n\u0026ldquo;不算很了解，大抵知道你的才华、你的流放，也听很多人都夸赞你的忠君、你的爱国。不过我一直很好奇，你到底是忠君还是爱国，抑或只是爱自己。\u0026rdquo;\n诗人似乎不想搭理我的问题，只说无趣。不过我不着急。\n\u0026ldquo;你一定会觉得我的问题毫无意义。但我们不妨想想你的过去，你曾千方百计地想要劝说怀王，却从不讲究方法；你愿大刀阔斧地实行改革，却全不在意拥簇。你总是有这样与那样看似极好的想法，然而从不放下身段妄想着各种要求\u0026rdquo;\n诗人不敢相信地看着我，天愈发阴沉。\n\u0026ldquo;你是否正视过张仪的游说技巧，是否有过学习商鞅变法的逻辑，还是杵在怀王面前把自负当清白，说起来自我感动，却不能解决半分问题。\u0026rdquo;\n诗人浑身哆嗦起来，裹挟水汽的冷风从汨罗吹来。我正说在兴头上。\n\u0026ldquo;不要认为爱国和忠君不可分述。你问过天，何不问问自己，怀王那个烂人能否给楚国，给楚地百姓交代。再问忠心耿耿地跟着对不起百姓的烂人的自己，又能否称得上\u0026hellip;\u0026rdquo;\n诗人的愤怒打断了我的诡辩。\n\u0026ldquo;你你\u0026hellip;你分明在胡说，你在侮辱我！\u0026rdquo;\n诗人毕竟不善言辞，他最终拍地而起起，不顾衣服粘上的黑泥向江畔走去。玉佩又铮鸣，天空飘起迷雨。\n我放肆的笑了起来，笑声尖锐、恶劣。\n我大声向诗人喊：\u0026ldquo;你这莫不是承认了你的卑劣，竟想抛弃楚国百姓一心寻死。\u0026rdquo;\n诗人果真转过头来，冰冷地看我。\n\u0026ldquo;我不忍看见百姓遭受屠戮、饥饿相食的惨状。\u0026rdquo;\n\u0026ldquo;嗨，别把逃避说的这么冠冕堂皇。你要是真不忍，那就得切身行动。把你的才华变成能打仗的武器，变成能果腹的粮食，而不是后世的悲叹。\u0026rdquo;\n\u0026ldquo;果真如此的话，你大可活着承认你的逃避。再不济，把这一切归咎给那该死的命运，醉醺醺地学庄周敲盆，洒脱生活，也能赚取一道佳话。何必死不见尸地跳进汨罗呢。\u0026rdquo;\n诗人说不出话来，只是悲哀的看着我。\n他转过身在此走向汨罗。\n\u0026ldquo;我本以为到最后能拥有一位朋友的。\u0026ldquo;诗人消失在江畔前轻轻说道。\n雨水狂躁地在爆雷声中落下，大风卷起汨罗江的湍流，乌云底下的芳草随黑泥地淹没在积水。\n我慌忙的捡起诗人落下的玉佩，索然无味地等待着湿漉漉的意识归于终寂。\n","date":"2025年12月6日","externalUrl":null,"permalink":"/create/novel/%E5%B1%88%E5%B9%B3%E4%B9%8B%E6%AD%BB/","section":"创作","summary":"","title":"屈平之死","type":"create"},{"content":"基本特点\r#\r抽象\r#\r数据抽象 描述某类对象的属性或状态\r行为抽象 某类对象的共同行为或功能特征\r封装\r#\r抽象得到的数据和行为相结合，形成有机整体\r继承\r#\r一般概念中的属性和行为可以被特殊概念共享\r多态\r#\r多态性是一段程序能够处理多种类型对象的能力\r通过强制多态、重载多态、类型参数化多态、包含多态4种形式实现\r强制多态和重载多态属于特殊多态性，只是表面的多态性\r通过虚函数实现包含多态，通过模板实现类型参数化多态\r类与对象\r#\r类的定义\r#\r数据成员\r函数成员\r类成员的访问控制\r#\r公有类型(public) 定义了类的外部接口\r私有类型(private) 只能被本类的成员函数访问，来自外部任何访问非法\r保护类型(protected) 性质与私有类型相似，子类成员可以访问\r对象\r#\r声明一个对象和声明一个一般变量相同\r访问对象的成员采取的是 \u0026quot;.\u0026quot; 运算符\r直接初始化或列表初始化\r类的成员函数\r#\r成员函数的实现\r函数的具体实现一般在类定义外，要指明类的名称\r返回值类型 类名::函数成员名(参数表){函数体}\r成员函数调用\r调用成员函数是，需要用 \u0026quot;.\u0026quot; 操作符指出调用针对的对象，称为目的对象\r成员函数中可以不使用 \u0026quot;.\u0026quot; 直接引用目的对象的数据成员和函数成员\r带默认形参值的成员函数\r内联成员函数\r隐式声明 将函数体直接放在类体内\r显式声明 保证类定义的简洁，可以采用inline显式声明的方式\r构造函数与析构函数\r#\r构造函数\r#\r类名(int a,int b,int c)[ :member1(a),member2(b),member3(c) ]{}\r构造函数作用是再在对象被创建时将对象初始化为一个特定的状态\r对象被创建时将自动调用构造函数\r没有参数的构造函数称为默认构造函数\r默认构造函数\r#\r合成的默认构造函数 编译器隐式地定义一个默认构造函数\r自定义默认构造函数\r编译器只在类不包含构造函数的情况下生产默认构造函数\r合成的默认构造函数可能会执行错误的操作\r委托构造函数\r#\r委托构造函数使用所属类的其他构造函数执行它自己的初始化过程\r如 Clock:Clock(0,0,0){} \u0026quot;:\u0026quot; 在这里是构造函数委托的语法标志\r复制构造函数\r#\r类名(类名 \u0026amp;对象){}\r形参是本类对象的引用，作用是使用一个已经存在的对象初始化同类新对象\r若未自定义，系统会在必要时自动生成隐含复制构造函数(clone)\r复制构造函数调用\r用类的一个对象去初始化该类的另一个对象\r函数的形参是类的对象\r函数的返回值是类的对象\r移动构造函数\r#\r类名(类名 \u0026amp;\u0026amp;对象){}\r左值和右值\r左值是位于赋值语句左侧的对象变量，右值是赋值语句右侧的值\r持久存在变量的引用称为左值引用，短暂存在可被移动的右值称为右值引用\r右值引用 \u0026amp;\u0026amp; 引用名=右值（不可绑定左值）\rmove函数可以将左值对象移动成为右值\r析构函数\r#\r~类名（）{delete [] 标识符}\r完成对象被删除前的清理工作，对象生存期即将结束时被自动调用\r默认析构函数无法清除动态内存，需要自定义析构函数\r析构函数不接受任何参数，但可以是虚函数\rdefault、delete函数\r#\rdefault函数 让编译器合成简单的无参默认、复制构造函数和析构函数\rdelete函数 删除不希望存在的相关操作（除析构函数外）(operate=delete)\r类的组合\r#\r组合\r#\r一个类内嵌其他类的对象作为成员\r创建类对象时，各个内嵌对象被自动创作，都需要被初始化\r内嵌对象构造函数先调用，本类构造函数后调用\r析构函数和构造函数顺序相反\r前向引用声明\r#\r相互调内嵌时，前向引用声明类\r由于不清楚类占据的内存，在嵌套时使用引用或指针\r*构造函数定义类型转换\r#\r用构造函数定义的类型转换\r#\r通过直接使用类名调用类的构造函数创建一个临时对象\r再调用临时对象成员函数返回转换的其他类型\r类的构造函数规定的类型转化允许隐含类型转换进行\r只允许显示执行的类型转换\r#\r在构造函数前加上explicit关键字使得类型转换只能显式进行\r","date":"2025年11月24日","externalUrl":null,"permalink":"/note/cpp/3.%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/","section":"笔记","summary":"","title":"3.类与对象","type":"note"},{"content":" 算法 为求解一个问题需要遵循的、被清楚地指定的简单指令的集合\r数学基础\r#\r四个定义\r#\r大O符号 描述算法时间/空间复杂度的上界（最坏情况）\r大Ω符号 描述算法复杂度的下界（最好情况）\r大Θ符号 描述算法复杂度的精确阶\r小o符号 描述增长速度严格低于\r相关结论\r#\rT1(N)=O(f(N)),T2(N)=O(g(N))\rT1(N)+T2(N)=max{O(f(N)),O(g(N))}\rT1(N)*T2(N)=O(f(N)*g(N))\rT(N)为k次多项式 ，则T(N)=Θ(N^k^)\rlog~k~N=O(N)，对数增长非常缓慢\r模型\r#\r做任何一件简单工作都恰好花费一个时间单元\r还假设模型机有无限的内存\r分析的问题\r#\r所使用的算法和对该算法的输入\r运行时间计算\r#\r一般法则\r#\r法则1 for循环的运行时间至多是改循环内语句的运行时间乘以迭代次数\r法则2 嵌套的for循环一条语句总运行时间为为该语句时间乘以所有循环\r法则3 顺序语句运行时间求和即可\r法则4 if-else语句运行时间不超过判断加代码块运行长者总的运行时间\r","date":"2025年11月24日","externalUrl":null,"permalink":"/note/datastructandalgorithm/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90.docx/","section":"笔记","summary":"","title":"算法分析","type":"note"},{"content":"\r壹\r#\r我已经记不起是什么时候来到牛心村的了，前年，还是大前年？当然也没记住自己是从那个方向来的，好像是东边的，又或者是南边。整天无所事事地四处逛的人只顾得眼前，而这些人叫混子。\n我是混子，所以牛心村的人大多不搭理我，除了村头的老头。老头没看出来我是混子，因为他自己是个疯子。早些年弄丢了自己的儿子后，他逢人便一边摸着干瘪的肚子，一边反复讲些发臭的旧事\u0026mdash;\u0026mdash;有关于他儿子的。\n牛心村的人断然不愿听他讲，就和懒得搭理我一样。但或许是物以类聚，我和老头却是相处的很愉快，因而我每天上村头有一阵了。\n老头一直讲着一样的旧事，讲完后还问我的看法。我总说对旧事我不感兴趣，混子不怀旧。老头听有人回应便十分开心，于是又讲一遍。\n贰\r#\r某天牛心村又来了个外人，着一身长衫，是个说书先生，从南面来，看上去有很多见识。他路过村头时，我很自然地抛下了老头跑去搭讪。\n我问他来牛心村是要说书吗。他说不，只是出来取材。我有点失望。我又说我带着他在牛心村溜两圈，他同意了。于是我和他东窜西窜，想要把村子逛遍。\n牛心村不小，傍晚我们才转悠完，最后来到了村子的深处。从这里向北边望，很近的地方上生着一座山。\n山特别高，贯穿了天空，山顶在云雾里。我不记得前几次看山有没有惊异，反正这次我很好奇，恰好旁边是见识很广的说书人。\n\u0026ldquo;这样的高山，有什么说法吗？\u0026ldquo;我问他。\n他沉思了一会，带着几分高兴，把腔调拉得很长，\u0026ldquo;你\u0026mdash;\u0026mdash;听过\u0026mdash;\u0026mdash;女娲补天的故事吗？\u0026rdquo;\n\u0026ldquo;没有，\u0026ldquo;我其实是听过的，但不记得了，\u0026ldquo;要不你跟我讲讲？\u0026rdquo;\n他于是说了一长串，大概是共工撞倒不周山，女娲炼石补天之类的。至于眼前的山，他说这山想来是女娲斩下的神鳖的足。\n我又问他，\u0026ldquo;那山顶会有什么呢？\u0026rdquo;\n\u0026ldquo;我的父亲去世前跟我说，或许会有宫殿，或许有数不尽的珠宝，或许能找到你珍爱的东西。\u0026ldquo;他眨了眨眼。\n\u0026ldquo;我打算爬上去看看，既是完成父亲的夙愿，也是满足自己的好奇。\u0026rdquo; 我有兴趣了，我拍了拍说书人的肩膀，让我跟他一起上山顶去。他看了我一眼，用拒绝的眼神。\n\u0026ldquo;你犯浑了？这不是一般的山，走到山顶兴许数年，你的妻子和孩子怎么生活？\u0026ldquo;他说的不无道理。\n我告诉他没必要担心，因为我是一个混子，没有妻子，也不会有孩子。\n\u0026ldquo;山上那片绿是树，树上有果，树下有动物，树旁是山泉。这周围的果子、动物能吃的不能吃的，我都门清，你总不能不吃不喝吧。\u0026ldquo;我想这能说服他带上我。\n\u0026ldquo;但是我不愿无故接受别人的帮助。\u0026ldquo;他仍不肯。\n\u0026ldquo;就当作是我对数不清的珠宝很感兴趣。你这样推脱，莫非是瞧不起我，嫌我累赘\u0026quot;我故意这样说。\n说书人的脸可见的红了，\u0026ldquo;你\u0026hellip;你怎么能无故质疑一个有道德的人。\u0026rdquo;\n\u0026ldquo;那你要带我一起上山顶，不然我就告诉别人你是个伪君子。\u0026ldquo;这句话有些过头，但我还是说了。\n\u0026ldquo;你这分明是胡搅蛮缠\u0026hellip;\u0026ldquo;说书人很生气。\n叁\r#\r说书人第二天还是答应了和我一起上山顶，不过他还带了牛心村旁寺庙的一个和尚。和尚很强壮，隔着僧袍都可以看到肌肉的轮廓。\n和尚肩上挎了一个大包，是说书人收拾的一些药，外敷的内服的都有，还有一个大帐篷，以及一点干粮和水。\n就这样，混子、说书人、和尚一同进了山。\n肆\r#\r在一片山林里找不到方向，我只好胡乱地跟着说书人和和尚沿上坡走。累了就靠在树旁歇会，渴了从河里捧一点，饿了就分辨一番，然后从树上摘或者在树下抓。\n尽管和尚走得很快，但我和说书人总容易需要休息。不得以，从清晨走到天黑，也只有很短的距离，相对于山顶而言。\n我们打算打持久战，也就不愿意晚上继续走。我挑了一处靠近水的地方，让和尚支好了帐篷。\n说书人点燃了熏香，三个人在劣质的香味里有一句没一句的聊天。\n我问和尚，\u0026ldquo;你平日在寺庙里念经吗？\u0026rdquo;\n\u0026ldquo;师傅和师兄弟都念，但我不念。\u0026ldquo;和尚说。\n\u0026ldquo;你为什么不念？\u0026ldquo;我不解。\n\u0026ldquo;他不识字，不会念。\u0026ldquo;却是说书人回答。\n和尚露出些不好意思，\u0026ldquo;但师傅说了不会念经没有关系的，佛法自在心间。\u0026rdquo;\n我哦了一声，但其实没懂。\n我接着问两人是怎么认识的。说书人告诉我他的父亲和和尚的师傅是莫逆之交，两人自小是朋友。\n\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\n后来的每天都是这样过去的，一开始我们还记时间，算算今天是什么日子。但到后来便算不清楚了，只凭树木荣枯模糊地感知\u0026mdash;\u0026mdash;\u0026mdash;我应该已经见过六次树叶落下了。\n山上渐渐地看不见动物了，还多出些我不认识的果子，我本来应该告诉他们的，但是我害怕，只称那些我不认识的是不能吃的。\n直到有一天我发现周围已经没有我认识的果子了，我只好告诉他们，其实我说谎了，我根本没有认识所有牛心村周围果子和动物，现在我们没有食物了。\n但我还是很想到山顶，于是我想说点什么。但还没说出，说书人开口了。\n\u0026ldquo;或许传说是假的\u0026hellip;山顶什么也没有\u0026hellip;我不能带着你们赴死\u0026hellip;要不我们还是下山吧\u0026hellip;.\u0026ldquo;话语带点懊丧。\n和尚没吱声，我说那我还是想上去。\n\u0026ldquo;你说是假的就是假的？我要上山顶验证他是假的。这样，这些不认识的果子我先吃，我吃完了没有事情你们再吃，这么多果子总有没毒的。\u0026rdquo;\n说书人不说话了。\n\u0026ldquo;我来吧，我的身体好，能抗毒，而且师傅说过的，佛祖会保佑我。\u0026ldquo;是和尚的声音。\n我明明知道这不对，但是很忧伤，人总是擅长借坡下驴，自私心战胜了混子。\n于是我们算是又有了食物。\n伍\r#\r印象里已经是第十次落叶了，和尚还是没有扛住。他吃了个通红的果子，刚一下肚，身体就起了反应，腹部绞痛、浑身发热。说书人连忙从包里掏出几瓶药，死马当活马医地给和尚灌了好些，但没有作用。\n和尚痛得佝偻着身体，就这样死去了，死前的最后几句话依旧是哪些果子能吃、哪些不能吃。说书人在旁边掉了眼泪，我默默地帮和尚整理身体和衣着，这时候我才发现，和尚当初有力的肌肉已经消失不见了。\n哪有不怕毒的身体，佛祖也怕。\n陆\r#\r我在地上刨出一个坑，把穿着僧袍的和尚，连同他的物品一道安葬了，只留下了一件他经常带着的佛珠。\n说书人在一旁边流泪边注视和尚的冢，问我还继续吗，声音里听不出悲喜。\n我咬咬牙，还继续，和尚的死不能没有结果。好在已经离山顶不远了，一路上的果子，也都有和尚试过能吃的，或许下一次落叶，就能到山顶了。\n柒\r#\r说书人也死了，倒在了山顶前。从树上突然窜出来了一只我没见过的怪物，像是蛇，却长了一身青色的毛，我来不及提醒，便一口咬在了说书人的肩膀上。怪物的嘴很毒，说书人的肩膀止不住地渗出血来，染红了整个长衫。他很虚弱地伸出发紫的手指，指向山顶，然后一命呜呼。\n这回，掉眼泪的和整理遗体的只剩我了。我把他安葬在一棵树下，只拿走了一把扇子。\n捌\r#\r拿着佛珠和扇子，我终于到了山顶，在看到十一次落叶之后。\n山顶真的什么也没有，没有宫殿，没有珠宝，我也没有找到我珍爱的东西，说书人说了一个假的传说，又说了一个真话。\n站在山顶看不到下面，只有白茫茫的一片。冷风吹过，我的嘴唇有些干裂，眼前有些发黑，便昏过去了。等我再醒来，分不清是清晨还是黄昏，只踉踉跄跄地一路下山。\n吃着来时吃过的果子，抑或是动物，喝着来时喝过的水，我又见了八次落叶，终于下山了。\n玖\r#\r我回到了村头，发现老头还在。看见我走过来，他说好久不见，又给我讲他那发了臭的旧事。听完，照例问我觉得怎么样。我没再回答他，只是讲了山上的故事，一个混子、说书人和和尚的故事。\n老头听完了咯咯地笑，我突然发觉我已经忘不掉山上发生的一切，开始怀旧了。\n拾\r#\r我记起自己是二十三年前从东面来到牛心村的了。\n","date":"2025年12月6日","externalUrl":null,"permalink":"/create/novel/%E5%B1%B1/","section":"创作","summary":"","title":"山","type":"create"},{"content":"结构体(Struct)\r#\r结构体是一种特殊形态的类，唯一区别在访问控制属性\r结构体中未指定访问控制属性的成员，默认为公有属性\r联合体(Union)\r#\r一组数据中某些数据只在一些情况下有效，另些在其他情况下有效\r联合体的全部数据成员共享同一组内存单元，至多只有一个成员有意义\r联合体各个对象成员不能有自定义的构造、析构函数，重载的赋值运算符\r联合体不能继承，因为也不支持包含多态\r无名联合体只声明一个成员项的集合，由成员项的名字直接访问\r枚举体(Enum)\r#\r不限定作用域\r#\renum (枚举类型名) {变量值类表};\r限定作用域\r#\renum(枚举类型名) ：类型 {变量值类表};\r*枚举类\r#\renum class 枚举类型名 {变量值列表};\renum struct 枚举类型名 {变量值列表};\r枚举元素具有默认值，也可以在声明时用赋值运算符另行定义\r","date":"2025年11月24日","externalUrl":null,"permalink":"/note/cpp/4.%E7%BB%93%E6%9E%84%E4%BD%93%E8%81%94%E5%90%88%E4%BD%93%E5%92%8C%E6%9E%9A%E4%B8%BE%E4%BD%93/","section":"笔记","summary":"","title":"4.结构体、联合体和枚举体","type":"note"},{"content":"抽象数据类型(abstract data type)\r#\rADT是一些操作的集合，可以有诸如并、交、测定大小、取余、查找等操作\r列表(List)ADT\r#\r列表模型\r#\r元素的集合，每一个元素有其相对位置\r支持操作 add() remove() search isEmpty() length() index()\rappend() insert(pos,item) pop() pop(pos)\r列表的数组实现\r#\r插入和删除的运行时间复杂度高，表的大小必须事先已知\r链表(linked list)（允许表不连续存储）\r#\r链表的每个节点均含有数据域和指向后继节点的指针域（Next指针）\r最后一个节点的Next指针指向NULL（0）\r留出一个标志节点，称为表头(header)或哑结点(dummy node)\rDelete可以通过修改指向待删除节点指针，使之指向下一节点实现\r双链表(double linked list)（允许双向扫描链表）\r#\r在链表节点结构上附加一个域，使节点包含指向上一个节点的指针\r增加了空间需求，使插入和删除的开销增加一倍，但简化了删除操作\r循环链表\r#\r最后节点反过来直指第一个节点\r链表的应用\r#\r基数排序(radix sort)\r栈(stack)ADT\r#\r栈模型\r#\r限制插入（进栈）和删除（出栈）只在栈顶进行的表，又称为FILO表\r支持操作 push() pop() peak()~（返回栈顶）~ isEmpty() size()\r栈的链表实现\r#\r操作指针的例程开销昂贵\r栈的数组实现\r#\r栈的应用（反转特性）\r#\r匹配括号\r进制转化\r前、中、后序表达式转化\r队列(queue)ADT\r#\r队列模型\r#\r在队尾(rear)插入（入队），在队头(front)删除（出队）的表，又称FIFO表\r支持操作 enqueue() dequeue() isEmpty() size()\r队列的数组实现\r#\r通过循环数组(circular array)实现\r队列的应用\r#\r模拟：约瑟夫问题\r模拟：打印任务\r双端队列(deque)ADT\r#\r同时具备栈和队列的特性\r双端队列的应用\r回文检测器\r","date":"2025年11月24日","externalUrl":null,"permalink":"/note/datastructandalgorithm/%E8%A1%A8%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97.docx/","section":"笔记","summary":"","title":"表、栈和队列","type":"note"},{"content":"\r壹\r#\r年轻的安雷亚对自己的职业向来有着不寻常的见解，他情愿将自己定义为一位出色的舞台剧演员，而非蹩脚的求学者。超过十年的表演经验给予了安雷亚充分的自信，他因此坚信自己深谙舞台剧的全部流程与每处细节，并为此感到骄傲。\n在腐朽的椅子上坐定，安雷亚习惯性的咬住自己右手大拇指的第一个关节旁的皮肤，而远处的凯布利必然戴着圣甲虫面具缓缓地乘太阳船升起，宣告舞台剧的正式开场。届时，他会忍着剧烈的疼痛将窄小的肩膀用蛮力鼓起，两旁生长出出三个不同面目的头颅。坐下顷刻间变作白马，安雷亚掌中名为布里欧纳克的长枪悄然出现。三百兵马不久便出现在他的身后，包括他们的三位长官，手持八把剑的鲁杰维、拿着金盾的伊阿洛维特与背着双刃战斧的拉迪加斯特。\n狭小的空间往外迅速膨胀，扩张着的边界模糊不清。皲裂的大地于是凭空出现，干涸的血迹不安地爬满了每一处间隙，战士倒下的尸体交错着铸成黑色荆棘，远处天穹阴沉地传来死者鬼魂不甘的嘶吼。战场的尽头是长相丑陋的弗莫尔，而这群深海巨人的首领巴罗尔正站在最前面，他那需要四个壮汉才能抬起的眼皮正服帖的盖在他的魔眼上。\n战神斯文托维特，或者说他的扮演者安雷亚，在良久的静默于僵持后，终于同他的兵马一道向弗莫尔们发起了冲锋。但在感受到深海巨人足以震颤大地的践踏向自己袭来引得两旁头颅阵阵目眩后，斯文托维特便明白冲锋并非明智的决定。然而他从不做后退的打算，取而代之的夹紧马肚、紧勒缰绳后的空中一跃。滞空在阴风里的刹那，斯文托维特手中的长枪脱手而出，布里欧纳克贯穿了巴罗尔的脑袋，巴罗尔唯一的弱点\u0026mdash;\u0026mdash;\u0026mdash;那只足以毁灭天地的魔眼猝不及防地破碎在颅腔内。\n在战争的最后，英勇的战神最终带领他的兵马剿灭了所有的深海巨人。而同样乘着一艘金灿灿地太阳船而来的拉会很愉悦地宣布了这场伟大胜利，在这之后拉粗粝的鹰喙便一直噙着笑容，在太阳船里期待着第二幕的好戏。\n安雷亚褪去了沉重的银甲，两旁的脑袋渐渐地萎缩成脓包消失不见。他即将扮演诸神信使、行路者的保护神、商人的庇护神、雄辩之神赫耳墨斯，这将会是更具难度的挑战，而此刻他脚上穿着插翅凉鞋，头戴翼帽，乌龟制成的里拉琴背在身后，手里已经握着象征商业的双蛇杖。\n迈出刚刚恢复平静的狭小空间，安雷亚立刻享受到了脚底那双长着翅膀的凉鞋所带来的便利。赫耳墨斯兴致浓烈地适应身体的轻盈与灵活，随后便迈开平均但高频的步伐，朝着奥林匹斯山的方向赶去，在那里，他将完成一项神圣的交易。余光瞥见周遭事物模糊成一片向后褪去，赫耳墨斯由衷地赞美惬意流淌的幸福的暖流，步伐如此坚定甚至忘却了耳边身躯不止的哀嚎，唯愿能尽早地同德墨忒耳完成约定中的交易。\n当急忙停在奥林匹斯山脚下，他终于清晰地听见膝盖的无声哭泣与脊椎骨不堪入耳的侮辱，他不由得弯腰曲背，在喘息中忍受疼痛的撕咬。默想着他从来守时的声誉与德墨忒耳的繁忙，赫耳墨斯匆忙地整理衣冠，再尽力从容地走进奥林匹斯山，同戴着麦穗编织的环形冠冕、手持水仙花的丰饶女神德墨忒耳交易粮食与经济。\n重新回到山脚的赫耳墨斯再也止不住颤栗起来，他慌忙地寻找苔藓覆盖的软泥地躺下，狼狈不已。膝盖抽象成点，脊椎骨模糊成线，阴晦的疼痛横波一般衍射到他身躯的每个角落。\n天空湛蓝得不真实，鹰首人身的拉依旧笑容满面。蘸满苔藓独特气息的泥土腥味萦绕在安雷雨鼻尖，不远处的奥林匹斯山笼罩在灿金色薄厚不均的迷雾里。安雷亚咬住右手大拇指的第一关节，舌头轻轻抵着僵硬的茧，庆幸于结缔组织的饱满。\n缓过神来的赫耳墨斯踏上了返程之旅。路途中他碰巧遇到了声势浩大的对峙。怒火从特拉洛克硕大的圆形迸出，长而尖的獠牙染上疯狂，托起水罐，倾盆大雨从天而降，银白泛蓝雷电充斥整个战场。阿耆尼立在水神的对面，两双手臂燃起火焰，三角印与仙杖爆发出灿光，融化空间的高温蒸干暴雨，骇人的雷电消失殆尽。按照往常的习惯，赫耳墨斯理应解决这类纠纷出面讲和，给对峙的两方一个恰如其分的台阶\u0026mdash;\u0026mdash;\u0026mdash;这是赫耳墨斯的日常工作。但此刻的赫耳墨斯并没有履行职责的心情，他低着头路过战场，长途跋涉后回到了那片狭小空间。\n拉不知何时已经离开，化身公牛莫努尔的阿图姆乘着略显残破的太阳船随太阳下潜。刚落下的帷幕再度拉开，没有给安雷亚休息的时间。\n腐朽的椅子抽出一根根遒劲的枝条，被藤蔓缠绕，蜿蜒在空间底下的深处，椅子的靠背生出粗糙的沟壑化作枝干，冠部是萃着金汁的墨绿色的枝叶。巨树尤克特拉希尔汲取着环境的能量而逐渐膨胀成熟，空间因此萎缩成一团废纸被岩石般坚硬的枝条戳破。\n尤克特希尔为奥丁铸造的王座随枝干而上，悬在空间外寒风呼啸不止的黑沉天空中。安雷亚俯瞰被严霜冰冻的大地上徘徊着犷野饿兽，聚啸的秃鹰盘旋着争食死尸。他听见金冠鸡报警的长鸣响彻诸神国度以及火焰雄鸡尖锐从死人国度传来的回应。\n死人指甲制成的大船上载满霜巨人与亡灵合编的军队而来，挣脱咒锁的芬里尔紧跟着海拉朝着王座前进。庄严的彩虹桥经巨人军队的蹂躏崩坏粉碎，海姆达尔的号角比托尔气绝前雷鸣般的痛苦呻吟更为凄厉。 被敌人手中光芒之剑击中的弗雷奄奄一息，海姆达尔被受刑造就的苍白头颅夺去生命。\n奥丁的头上金盔仍然闪亮，身后的蓝色斗篷火焰般起伏。骑着嘶鸣不已的八足天马，安雷亚举起昆古尼尔掷向贪婪地啃啮着众神尸体的尼德霍格，于事无济地死在了芬里尔的利齿下。\n这场无可挽回的诸神黄昏终于归于死寂的大沉默和永劫的黑暗。当安雷亚从昏沉中苏醒时，他回到了形态规整的狭小空间内，而阿图姆已经驾驭着太阳离去。吸吮着拇指的第一个关节，安雷亚因表演结束而舒气，拖着疲惫的身躯，他一面抚平心悸，一面慢悠悠地离开。\n贰\r#\r表演舞台剧的经历毫无意外地会成为安雷亚最刻骨铭心的记忆，但日复一日的枯燥表演让安雷亚还是做出了更换一份职业的决定。\n于是在某月的第二个星期三，安雷亚踏上了他的求职之旅，计划在心理医生那谋求到精神病人的职业。\n绕过了特拉洛克和阿耆尼交战的地带，安雷亚在凯布利的一路注视下来到了全市最好的心理医生面前。医生的办公室里很整洁，弥散有一股有别于凯布利的太阳清香。阳光穿过玻璃窗四处飞溅，透过窗往外不能看到圣甲虫面具，窗户旁挂着一副流淌着阳光的画，画上是圣洁意味的黄金盘和权杖。医生是一个和煦的中年人，语调里浸润着安雷亚所能想到的一切优秀品质。\n\u0026ldquo;这位年轻的先生，你看起来有一些烦恼需要我的帮助。\u0026rdquo;\n\u0026ldquo;太对了，医生。我感觉自己患上了臆想症。我时常想象自己是神，一会是战胜怪物的战神，一会是奔波的信使，甚至是神王，死于灭世的灾难。\u0026rdquo;\n\u0026ldquo;但我能看出来，你其实分得清楚什么是幻想，什么是现实，是这样吗？\u0026rdquo;\n\u0026ldquo;是这样，但我不能控制我的幻想，它总在发生。\u0026rdquo;\n\u0026ldquo;清楚现实与幻想的界限总归是一件值得高兴的事，我见过太多沉溺在幻想死去的人了。不过你提到无法控制幻想的发生，看来你最近的压力很大。\u0026rdquo;\n\u0026ldquo;是这样，医生。大家都知道的，学生的压力总是很大，天没大亮就必须坐进教室里，繁星闪烁许久都不能如愿归家。\u0026rdquo;\n\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\n\u0026ldquo;我想你需要一些身心的放松和恰当的休息，你可以从我的助手那拿上一瓶香薰，它有助于缓解疲劳。\u0026rdquo;\n\u0026ldquo;所以医生，我并没有臆想症是吗？\u0026rdquo;\n\u0026ldquo;当然，臆想症可是很严重的疾病，他们中最典型是固执地以为自己是只不用吃喝的蘑菇。不过，我诚恳建议你可以抽时间去趟医院体检一番身体。\u0026rdquo;\n\u0026ldquo;这是什么意思？\u0026rdquo;\n\u0026ldquo;虽然我不够专业，但你的脸色有些苍白得不正常了，年轻的先生。\u0026rdquo;\n从医生的办公室走出，拉那副总是笑着的鹰首代替凯布利俯视着城市。安雷亚为没能获得精神病人的职业感到失落，不禁咬住了拇指，但他很快振作起来，这位有着崇高品德的医生给他提供了新的入职方向\u0026mdash;\u0026mdash;\u0026mdash;病人。\n心理医生的办公室离位于市中心的医院有一段不短的路程，他不由得怀念起他那双能让身体变得轻盈的插翅凉鞋。而在接连穿过基诺波利亚等一众城市后，他来到了这座浑身以钢铁巨兽的尸体铸成的医院面前。\n蛇缠绕的手杖被制成雕塑立在医院的门前，传闻中医院的院长从阿斯克勒庇俄斯那偷来了戈耳工的血液藏在了医院大楼的最底层。\n忍受着草药令人作呕的气味，安雷亚在环形大厅挂号缴费后马不停蹄地融入一项又一项检查的长队中，在花费了三小时二十八分钟四十六秒后，他终于完成了所有的项目坐在了最后的医生面前。\n感觉到草药味侵入到皮肤下，安雷亚讨厌这股和弗莫尔相仿的味道。他沉默的观察着眼前翻看报告的医生。\n穿着印有蛇杖标志的白大褂，这位戴这眼镜的医生很不幸运的谢了顶，不过这恰好和面容上的沟壑一起为医生可靠性的证明做出了卓越的贡献。乳色眼白间的瞳孔与掺杂银色的胡须略失神采，但无损于此刻医生的严肃表情。\n如想象中一样的患有炎症的声音响起，宣布着残酷但令人无限遐想的消息，安雷亚患上了一种棘手的疾病。\n\u0026ldquo;你的皮肤下，内脏以及颅腔里长满了包裹着混合液体的囊肿，里面含有浓度不低的盐酸与激素。而且这些囊肿很不安分，有扩散蔓延的迹象。\u0026rdquo;\n\u0026ldquo;皮肤下的囊肿或许还能想办法治疗，但内脏和颅腔内的囊肿，目前没有任何一家医院敢说自己能解决。如果我是你，我大概率会乘着还能动好好享受一段时光。\u0026rdquo;\n安雷亚出医院时，几乎快看不到阿图姆的身影了，站在医院前的广场里面对着蛇杖雕塑的背面，获得一份新职业的安雷亚呼吸着清新的空气，感到从未有过的酥麻清流在心脏形成漩涡化作快乐。\n为了将新职业做到尽善尽美，安雷亚仔细体悟身躯内液体的摇晃、牵引、挤压，曾经反复出现的疼痛于是都有了缘由。他小心翼翼的走在大街上尽情享受着喧闹沸腾的夜色，布有血丝的眼睛在惨白的脸上搜寻着来往人群各式的情绪。\n撞上一只流浪的哈士奇海盗狗，他可惜于手里没有趁手的里拉琴不能使这凶恶的刻耳柏洛斯昏睡；遇见了精神矍铄的老人，他大声赞叹对方的智慧，表示自己对伊特萨姆纳的崇高敬意；他衣着干练的女子面前深情并茂地吟诵\u0026quot;狱囚冤债尽消磨\u0026quot;的传说；他向十岁的可爱小孩关切的询问今天的铅箭瞄准了哪两位。\n在热闹的大街一角，安雷亚被精神病院尽职尽责的医护用药物麻醉在地，闭眼的时刻，他看见旷世的钟楼悄然出现，而穷响寰宇的钟声随后潮水般汹涌响起。日月的轮换交替，钢铁的城市坍塌又起，世代在金鱼眨眼的日子里更迭。\n坐在病床上的咬着右指的安雷亚再也想不起他那荒诞不羁的学生时代。\n","date":"2025年12月6日","externalUrl":null,"permalink":"/create/novel/%E5%AD%A6%E7%94%9F%E6%97%B6%E4%BB%A3/","section":"创作","summary":"","title":"学生时代","type":"create"},{"content":"标识符的作用域和可见性\r#\r作用域(标识符在程序正文中有效的区域)\r#\r函数原型作用域\r函数声明时形式参数的作用范围\r局部作用域\r仅在特定代码块(函数、循环、条件)中可见可用\r类作用域(struct)\r成员函数中未声明同名局部标识符，可以直接访问成员\r通过表达式x.m(对象访问)或者X::(类访问),访问成员\r通过ptr-\\\u0026gt;m(ptr是指向对象的指针)这样的表达式访问成员\r其他特殊访问和作用域规则\r限定作用域的enum枚举类\renum class/struct 与类的访问方式相同\r文件作用域\r不再前述各个作用域中出现的声明,具有文件作用域\r作用域开始于声明点,结束于文件尾\r具有文件作用域的\r命名空间作用域(全局变量的划分工具)\rnamespace 命名空间名{代码声明}\r避免重名的冲突\r可见性\r#\r程序运行到某一点,能够引用到的标识符,就是该处可见的标识符\r多个具有包含关系的作用域中声明同名标识符,外层标识符内层不可见\r对象的生存期\r#\r静态生存期\r#\r如果对象的生存期与程序运行期相同,我们称它具有静态生存期\r文件作用域声明的对象都具有静态生存期\r函数内部局部作用域\r使用关键字static使得声明对象获得静态生存期\r只在函数初次调用初始化,后续调用共用一个内存\r类成员static修饰\r表示该类所有对象共有\r动态生存期\r#\r其余对象都具有动态生存期\r局部作用域中声明的具有动态生存期，习惯上也称局部生存期对象\r局部生存期诞生于声明点，结束于声明所在块执行完毕之时\r类的静态成员\r#\r静态数据(类属性)\r属性为整个类共有，不属于任何一个具体对象，用static关键字声明\r静态数据成员具有静态生存期\r静态函数成员\r静态成员函数可以直接访问该类的静态数据和函数成员\r访问非静态成员，必须通过对象名\r类的友元\r#\r友元关系提供了不同类(对象)的成员函数间、成员函数与一般函数间进行数据共享\r友元函数\r#\r友元函数是在类中用关键字friend修饰的非成员函数\r函数体中可以用过对象名访问类的私有和保护成员\r在成员函数前方添加friend构造型来表征\r友元类\r#\r一个类可以将另一个类声明为友元类\r则A类的所有成员函数都是B类的友元函数，都可以访问B的私有和保护成员\rclass B{ \\... friend class A; \\...};\r友元关系是不能传递的，友元关系是单项的\r共享数据的保护\r#\r常对象\r#\r常对象必须进行初始化，而且不能被更新\r用const修饰的类成员\r#\r常成员函数\r类型const(返回值是const) 函数名(参数表) const(函数成员为const)；\r常数据成员\r常引用\r常引用所引用的对象不能被更新\rconst 类型 \u0026amp;引用名；\r非常引用只能绑定普通的对象，常引用可以绑定常对象\r多文件结构和编译预处理命令\r#\rc++程序的一般组织结构\r#\r通常一个项目至少分为3个文件：\r类定义文件(\\*h文件) 类实现文件(\\*cpp文件) 类的实现文件(\\*cpp文件)\r一般将需要分配空间的定义放在源文件；将不需要分配空间的放在头文件\r内联函数特殊，需要被多个编译单元调用的内联函数应出现在头文件\r外部变量与外部函数\r#\r外部变量\r如果变量还能被其他文件使用，那么就称这个变量是外部变量。\r文件作用域中定义的变量，默认情况下都是外部变量\r其他文件中如果需要使用这一变量，需要用extern关键字加以声明\r外部函数\r所有类之外声明的函数没有特殊声明都具有文件作用域\r在调用前进行引用性声明后，这些函数可以在不同编译单元被调用\r可以不加extern\r将变量和函数限制在编译单元内\r使用static关键字来修饰文件作用域的变量和函数，与extern起相反作用\r标准C++库\r#\rC语言中，系统函数、系统的外部变量和一些宏定义都放置在运行库中\rC++的库中还加入了预定义的模板和类\r标准C++类与组件在逻辑上分为：\r输入输出类 容器类与ADT类 存储管理类\r算法 错误处理 运行环境支持\r使用标准库时，需要引入指定命名空间 std\r编译预处理\r#\r#include指令 (包含指令)\r将另一个源文件嵌入当前源文件中该点处\r#include \\\u0026lt;fileName\\\u0026gt;\r按标准方式搜索，文件位于系统目录的include子目录下\r#include \u0026quot;fileName\u0026quot;\r首先在当前目录中搜索，若没有，再按照标准方式搜索\r#define和#undef指令\r#define 宏定义 #undef 删除宏\r条件编译指令\r限定程序中的某些内容在满足一定条件才参与编译\r#if\\... #elif\\... #else\\... #endif\\...\r#ifdef 如果标识符被定义过\r#ifndef 如果标识符没有被定义过\rdefined 操作符\r预处理符而非指令\rdefined(标识符) 若标识符被#define定义过，且未经#undef删除，则为true\r*常成员函数的声明原则\r#\r不会改变对象状态的函数声明为常成员函数\r会改变成员状态的函数不能声明为常成员函数，成员状态不只有非静态成员对象值\r","date":"2025年11月24日","externalUrl":null,"permalink":"/note/cpp/5.%E6%95%B0%E6%8D%AE%E7%9A%84%E5%85%B1%E4%BA%AB%E4%B8%8E%E4%BF%9D%E6%8A%A4/","section":"笔记","summary":"","title":"5.数据的共享与保护","type":"note"},{"content":"搜索\r#\r顺序搜索\r#\r顺序搜索算法的时间复杂度为O(N^2)\r二分搜素\r#\r如果列表有序可采用二分搜索\r二分搜索算法的时间复杂度为O(logN)\r散列\r#\r散列表\r元素集合，储存在槽中便于查找\r载荷因子\r槽的占用率称为载荷因子\r散列函数\r散列函数将散列表中的元素与其所属位置对应起来，常常是取余函数\r完美散列函数\r给定一个元素集合将每个元素映射到不同的槽\r扩展取余函数的方法\r折叠法\r将元素切成等长的部分然后相加再求散列值\r平方取中法\r先将元素取平方，然后提取中间几位数求散列值\r散列函数一定要高效，避免成为存储和搜索的负担\r冲突\r散列函数将两个元素都放入同一个槽\r处理冲突\r通过系统化方法在散列表中安置冲突的第二个元素\r开放地址法\r线性探测\r在散列表寻找下一个空槽或地址\r容易造成散列表元素出现聚集现象\r平方探测\r线性探测的变体，不采用固定的跨步大小\r链接法\r允许散列表中的同一个元素上存在多个元素。\r发生冲突时元素仍然被插入其散列值对应的槽中。\r随着同一个位置上的元素越来越多，搜索变得越来越困难\r排序\r#\r冒泡排序O(N^2)\r#\r每一轮遍历都将下一个最大值放到正确的位置上\r如果在一轮遍历中没有发生元素交换，就可以确定已经有序，使其提前终止\r选择排序O(N^2)\r#\r每次遍历列表时只做一次交换，每次遍历只交换一次\r插入排序O(N^2)\r#\r在列表较低的一端维护有序的子列表，并逐个将每个新元素\u0026quot;插入\u0026quot;子列表\r希尔排序[可以到达O(N^3/2)]\r#\r将列表分成数个子列表，并对每一个子列表应用插入排序\r切分列表是希尔排序的关键，并非连续切分，使用增量i切分列表\r归并排序\r#\r分支策略改进排序算法，归并排序是递归算法\r基准情形 如果列表为空或者只有一个元素，那么有序\r不断演进 列表一分为二两部分递归调用分别排序\r快速排序O(NlogN)\\[有可能退化\\]\r#\r也采用分治策略，但不使用额外的存储空间\r首先选出基准值（多种方法，尽量均匀分割）\r帮助切分列表，基准值的最终的位置是分割点\r接着进行分区（若左小右大）\r左指针找到比基准大的，右指针找到比基准小的，两者交换\r若右指针小于左指针\r右指针即为分割点\r递归调用该过程\r","date":"2025年11月24日","externalUrl":null,"permalink":"/note/datastructandalgorithm/%E6%90%9C%E7%B4%A2%E5%92%8C%E6%8E%92%E5%BA%8F.docx/","section":"笔记","summary":"","title":"搜索和排序","type":"note"},{"content":"\r迷宫\r#\r一般的人或许很难想象，一个人有关的过去，像积木被孩童打碎后重新拼凑一样丢失了本在的结构。但事实就是，这些积木那样莫名地被选中，肆意地构筑起一座曲折离奇的迷宫。\n是的，我必须强调，原地打转的我，刚从迷宫中醒来，被无尽迷乱的过去困缚。而我也清楚地知道，唯有走到这座弥漫不详气息迷宫的尽头，我才能呼吸在已然到来的未来，假若我应有。\n没有妩媚的阿里阿德涅赠送我线团与利剑，我能拥有的只有勉强运行的逻辑，和一些残存的概念。我必须也只能相信它们就是走出迷宫的关键，纵然我不及忒修斯神勇。\n坐标\r#\r一个原点，一个尺度，一个方向。\n第一个英雄杀入围城？血肉的果实刚刚成熟？精神的园圃栽出鲜花？所有纷乱的伊始，唯一疯狂的原点，就静悄悄地藏匿在幻梦似的生命史，不必追溯到盘古开天后的第一细胞。我装作不甚在意地，凯撒般独裁地，宣告园圃某天尚未开花的灰蒙下午足以胜任那个令人晕眩的奇点。\n寥寥的褪色胶片，以及比思绪还要更快的无。在这里，空间不曾存在，时间一点一点失去锚点。只剩足以磨灭永恒的逻辑，无可奈何地充当度量的单位。我称之为洛日迦，区别于逻辑的本在。\n逻辑的残酷游戏向着充分与必要多轴并行。我武断不失冷静地规定，充分是这个残酷游戏的正方向，并且断言任何命题相对另者同时具备着充分与必要的性态，从而让基于洛日迦的运算浮出水面。\n映射\r#\r褪色的胶片不足以被抽丝剥茧，编织成线团的结。于是某种对应关系必须被发现，从模糊似无的一帧，张成箭头指向笺纸上的一段。那不该是联结主义的方法，将胶片铰碎，编号，再运算，酷烈得令人颤栗。\n假如避开空洞般惨白，理应温和地触碰脸庞的平仄，或是红唇微翘，蒙雾的眼眸半阖，不排除哑暗的水痕，柔软黑发被浸湿。我姑且用\u0026quot;面部表情\u0026quot;统摄它们，更准确说，谨慎地保留地将它们锁在集合里，再贴上标签。\n以百计这样的笼子被整齐码放，我小心翼翼地捧起种子，埋入笼子里抽离的符号。荆棘丛生，枝蔓疯长，字字句句被孕育，坠落，扎根，生长，支撑。洛日迦终于孱孱流动，褪色胶片一页页翻过，放映某种可能的已往。\n连续\r#\r是镌刻往日残骸的传记，是纯粹洛日迦的织体。我试探地同阴影对话，刺鼻的陌生感牵拉忐忑，在胸腔激烈跳动。流动的洛日迦未免干脆，被隔绝的胶片不可稠密，更不可完备。我本该赋予洛日迦柔韧，又或者不拒绝分割。\n如此，洛日迦才有某种伟力，许是趋近的执着，不乏等同的恰巧，有资格邀请幽邃海底的庞然白骨欣然返生。与之相仿的，阴影升维，形象幻化，色彩融化又凝固，汹涌的镜面渐渐歇息。\n\u0026ldquo;你是催化剂，还是发明物，或者实验中产生的无用泡沫\u0026rdquo;\n\u0026ldquo;亦或许三者都是。\u0026rdquo;\n稠密而完备的怪物诞生后如是说。\n迷宫\r#\r黑、灰与白的丑恶之物从怪物肢体增生。\n原点一再坍缩，洛日迦的产物分崩离析，字句在繁衍中衰退。昏黄的胶片散落四处，扎根集合的荆棘被胡乱的搅碎。直到怪物散成轻烟，消匿在狼藉一片的迷宫。\n我在沉默中等待，再一次自迷宫中醒来。\n","date":"2025年12月6日","externalUrl":null,"permalink":"/create/novel/%E8%87%AA%E8%BF%B7%E5%AE%AB%E4%B8%AD%E9%86%92%E6%9D%A5/","section":"创作","summary":"","title":"自迷宫中醒来","type":"create"},{"content":"数组\r#\r具有一定顺序关系的对象集合体，组成数组的对象是数组的元素\r每个元素有n个下标的数组称为n维数组\r数组的声明\r#\r数据类型 标识符[][]...[];\r数组的使用\r#\r通过下标来访问数组中的元素(下标必须为整数且不得越界)\r数组的存储\r#\r数组元素在内存中是顺序、连续存储的(包括多维数组)\r数组的初始化\r#\r在声明数组时给部分或全部元素赋初值\r如果列出全部元素初值，可以不做元素个数说明\r多维数组可以按第一维进行分组，用括号将每一组括起来\r数组也可以被声明为常量\r数组作为函数参数\r#\r使用数组名传递数据时，传递的是地址\r形参数组和实参数组的首地址重合，后面元素各自对应\r对象数组\r#\r数组的元素也可以是自定义类型\r通过对象数组[下标].member可以访问公共成员\r指针\r#\r内存空间的访问方式\r#\r计算机的内存储器被划分为存储单元按一定规则编号，即为地址\r地址编码的最基本单位是字节，每字节由8个二进制位组成\rCpp程序中通过变量名和地址利用内存单元存取数据\r不传递变量的值，只传递变量得地址可以减小系统开销\r指针变量的声明\r#\r指针变量是用于存放内存单元地址的\r数据类型 *标识符(这里的*表征声明指针);\r指针可以指向各种类型，包括基本类型、数组(数组元素)、函数、对象、指针\r与地址相关的运算 \u0026ldquo;*\u0026rdquo; and \u0026ldquo;\u0026amp;\u0026rdquo;\r#\r\u0026quot;*\u0026quot; 指针运算符(解析运算符)\r表示获取指针所指向的变量的值，是一元操作符\r\u0026quot;\u0026amp;\u0026quot; 取地址运算符\r得到一个对象的地址，也是一元运算符\r* \u0026quot;\u0026amp;\u0026quot;出现在变量声明左边时，表示声明引用；\r出现在等号右边或执行语句时表示取地址\r指针的赋值\r#\r定义指针时进行初始化赋值，或者定义后单独使用赋值语句\r多个指针可以指向同一个变量，一个指针只能指向一个变量\r数组名称实际上是一个不能赋值的指针常量\r指向常量的指针\rconst 类型 \\*p;\r指针指向的值不能通过指针改变，但指针本身可以改变指向另一个对象\r指针类型的常量\r类型 \\* const p;\r指针本身的值不能改变，指向某个固定的对象\r一般指针的值只能赋给同类型指针，但void类型可以储存任何类型对象地址\rvoid指针一般只在指针指向对象不确定时使用\r指针运算\r#\r指针是一种数据类型，可以参与部分运算(算术运算、关系运算和赋值运算)\r算术运算\r指针可以和整数做加减法运算，表达指针指向位置后移或前移\r如(pl+nl)(或pl\\[nl\\])表示pl指向位置后移nl个数(nl\\*typebyte个字节)\r一般指针的算术运算和数组使用相联系，避免破坏地址数据或代码\r关系运算\r指向相同类型数据的指针之间进行的关系运算\r两个指针相等，表示两个指针指向同一个地址\r指针变量可以和整数0进行比较，0专用于表示空指针\r空指针不指向任何有效地址\r用指针处理数组元素\r#\rbegin和end\rbegin返回指向数组首元素的指针\rend返回返回指向数组尾元素下一元素的指针\r这两个函数定义在iterator头文件\r指针数组\r#\r元素都是指针变量的数组，每个元素必须是同一类型的指针\r数据类型 \\*pa\\[下标\\]；\r可以用数组初始化指针数组，元素为数组首地址\r指针作为函数参数\r#\r在不同函数之间传递大量数据时程序开销非常大\r如果传递数据存放在连续内存区域中，可以只传递数据的起始地址\r指针作为函数的形参有三个作用\r使实参与形参指向共同内存空间，达到参数双向传递\r减少函数调用时数据传递的开销(一般会使用引用，部分使用指针)\r通过指向函数的指针传递函数代码的首地址\r指针型函数\r#\r指针也可以是函数的返回值，返回值为指针的函数即为指针型函数\r在函数结束时把大量的数据从被调函数返回到主调函数中\r数据类型 *函数名(参数表){函数体}；\r函数返回数组指针\reg.1 typedef int arr[ ]; arr * fun( int i );\reg.2 int ( *fun ( int i ) )[ ];\reg.3 auto fun( int i ) -\u0026gt; int( * )[ ]; //尾置返回类型\reg.4 decltype( a ) *fun( int ); //返回值类型和a数组相同\r指向函数的指针\r#\r执行程序的代码也会被调入内存并占据一定的空间\r函数名就表示函数的代码在内存中的起始地址\r调用函数的通常形式的实质就是函数代码首地址\r函数指针\r函数指针是专门用来存放函数代码首地址的变量\r数据类型 ( * 函数指针名) (形参表)；\r函数指针使用前需要赋值，指向一个存在的函数代码起始地址\r对象指针\r#\r每个对象在初始化之后都会在内存中占有一定的空间\r对象指针就是用于存放对象地址的变量\r一般的对象指针\r声明的语法形式 类名 *对象指针名；\r对象指针可以方便地访问对象的成员\r对象指针名 -\u0026gt; 成员名\r( * 对象指针名).成员名\rthis指针(类似python中self)\r隐含于类非静态成员函数的特殊指针，是常量型指针\rthis指针指向正被成员函数操作的对象\rthis指针是成员函数的一个隐含形参\r指向类非静态成员的指针\r类的成员自身也可以被存放道一个指针变量中，进而通过指针访问成员\r数据成员 类型说明符 类名 :: *指针名;\r函数成员 类型说明符 (类名 :: *指针名)(参数表);\r对类中成员取地址时也需要遵循访问权限约定(\u0026amp;类名::成员名)\r通过指针访问类的成员\r对象名.*数据成员指针名/(对象名.*函数成员指针名)(参数表)\r对象指针名-\u0026gt;*数据成员指针名/(对象指针名-\u0026gt;函数成员指针名)(参数表)\r指向类静态成员的指针\r对类静态成员的访问不依赖对象，可以用普通指针\r动态内存分配\r#\r动态内存分配即在运行过程中按照实际申请适量内存，试用结束后释放\r这种在程序运行过程中申请和释放的存储单元也称为堆对象\r申请和释放过程一般称为建立和删除，使用new和delete运算符\rnew运算符\r#\r动态创建堆对象 new 数据类型(初始化参数列表)\r如果内存申请成功，new运算便返回一个指向新分配内存首地址的指针\r如果申请失败会抛出异常\r建立基本类型对象\r初始化过程即为赋值 int *p=new int(2)\r如果不希望设定初始值可以省去括号 int *p=new int\r如果保留括号但不写值，默认用0初始化\r建立类的实例对象\r根据初始化参数列表(参数类型和个数)调用类的构造函数\r若类存在用户定义的默认构造函数，则new T和new T()等效\r若用户未定义，则new T()会默认为基本类型和指针类型成员赋0值\rdelete运算符\r#\r用来删除由new建立的对象，释放指针所指向的内存空间 delete 指针名;\r如果被删除的是实例对象，对象的析构函数将被调用\rnew建立的对象只能使用delete一次，多次删除会导致错误\r用new分配的内存必须用delete释放，否则会导致\u0026quot;内存泄露\u0026quot;\rvector创建数组\r#\r静态数组和new动态创建数组难以检测下标越界的错误\rCpp标准库提供了被封装的动态数组------vector，它是一个类模板\r*vector\\\u0026lt;元素类型\\\u0026gt;数组对象名(数组长度,元素初值)；//数组长度可含变量\rvector定义的数组对象所有元素都会被初始化，若无元素初值默认赋0\rvector数组对象是分装数组类的实例，用下标访问元素，但对象名不为首地址\r数组对象数组对象名.size( ) 可返回数组大小\r更多特性在类模板一章中介绍\r深层复制与浅层复制\r#\r浅层复制\r#\r实现数据项的复制(值复制)，指针变量也会指向同一地址\r在释放动态内存空间时可能会delete一处地址多次\r深层复制\r#\r编写构造函数使得指针指向新地址，形成真正的副本\r字符串\r#\r用字符数组存储和处理字符串\r#\r字符串常量是一个隐含创建的char数组，字符串常量表示数组的首地址\r可以将字符串常量赋给常量字符串指针\r字符串变量也可以用类似方式来表示，将元素放入char数组，末尾放置一个 '\\0'\rchar数组需使用strcpy(复制)，strcmp(排序)，strcat(拼接)等函数处理字符串\rstring类\r#\rCpp中预定义了字符串类，提供了对字符串进行处理所需要的操作\r使用string类需要包含头文件string，封装了串的属性和一系列访问属性的函数\r构造函数\rstring( ) //建立长度为0的串\rstring(const string \u0026amp;rhs) //复制构造函数\rstring(const char *s) //用指针s指向的字符串常量初始化string对象\rstring(const string \u0026amp;rhs ,unsigned int pos ,unsigned int);\r//将对象rhs中的字符串从pos往后取n个字符初始化string对象\rstring(const char *s ,unsigned int n);\r//用指针s指向的字符串前n个字符初始化string对象\rstring(unsigned int n ,char c); //将c字符重复你次初始化string对象\rstring类的操作符\r方便地完成字符串复制、字符串链接、字符串比较等功能\r字符串比较是按照字典序比较\r常用成员函数功能\rappend(const char *s); //将字符串s添加在本串尾\rassign(const chae *s); //将s指向的字符串赋值给本对象\rcompare(const string \u0026amp;str) ; //比较本串与str串大小，小于负数大于正数\rinsert(unsigned int pos ,const char *s); //将s指向的字符串插在pos之前\rsubstr(unsigned int pos ,unsigned int n) ; //取本串pos后的n个字符做子串\rfind(const basic_string \u0026amp;str); //查找并返回str在本串第一次出现的位置\rlength( ); //返回串的长度(字符个数)\rswap(string \u0026amp; str); //将本串与str中的字符串进行交换\r*指针与引用\r#\r引用和指针常量使用形式的对比\r引用运行的实现机制最终不得不借助地址，二者殊途同归\r*引用只能在初始化时指定被引用的对象，类似于指针常量\r*引用不可以再被取地址*，引用一经定义本身占据的空间被完全隐藏\r引用可以更加方便安全地实现数据双向传递等简单需求\r*reinterpret_cast\r#\r*可以将一种类型的指针转换成另一种类型的指针\r可以在不同类型对象、函数，类函数、数据成员成员之间转换\r*有很大的危险性和不确定性\r*const_cast\r#\r*将数据类型中const属性去除\r在某些固定场合适当地使用它可以是安全的\r","date":"2025年11月24日","externalUrl":null,"permalink":"/note/cpp/6.%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/","section":"笔记","summary":"","title":"6.数组、指针与字符串","type":"note"},{"content":"树相关术语\r#\r节点\r#\r节点可以有自己的名字\u0026quot;键\u0026quot;，也可以附带信息称作\u0026quot;有效载荷\u0026quot;\r根节点 唯一没有入边的节点\r子节点 一个节点通过边与子节点相连\r父节点 一个节点时所有子节点的父节点\r兄弟节点 具有同一个父节点的节点互称为兄弟节点\r叶节点 叶节点没有子节点\r边\r#\r两个节点通过一条边相连，表示它们之间存在关系\r除根节点外其他每个节点仅有一条入边，出边则可能有多条\r路径\r#\r由边连接的有序节点列表\r子树\r#\r一个父节点以及其所有后代的节点和边构成一颗子树\r层数\r#\r节点n的层数是根节点到n的唯一路径长度\r高度\r#\r树的高度是其中节点层数的最大值\r树的定义\r#\r节点与边\r#\r有一个根节点\r除根节点外其他每个节点由与唯一的父节点相连\r从根节点到其他每个节点都有且只有一条路径\r如果每个节点最多有两个子节点，称之为二叉树\r递归定义\r#\r一棵树要么为空要么由一个根节点和零棵或多颗子树构成\r每颗子树的根节点通过一条边连到父树的根节点\r树的实现\r#\r嵌套列表(python)\r#\r节点与指针\r#\r每个节点的所有子节点放在树节点的链表中\r节点的指针可以指向兄弟或儿子\r树的遍历\r#\r前序遍历\r#\r先访问根节点，然后递归地前序遍历左子树，最后递归地前序遍历右子树\r中序遍历\r#\r先递归地中序地遍历左子树，然后访问根节点，最后递归地中序遍历右子树\r后序遍历\r#\r先递归的后续遍历右子树，然后递归地后序遍历左子树，最后访问根节点\r二叉树的操作\r#\rgetLeftChild( ) 返回当前节点的左子节点对应二叉树\rgetRightChild( ) 返回当前节点的右子节点对应二叉树\rsetRootVal(val) 在当前节点储存val对象\rgetRootVal( ) 返回当前节点存储的对象\rinsertLeft(val) 新建当前节点的左子节点\rinsertRight(val) 新建当前节点的右子节点\r二叉搜索树(binary tree)\r#\r*依赖于二叉搜索性：所有小于父节点键在左子树，所有大于父节点键在右子树\r搜索树的操作\r#\rMap( ) 新建一个空映射\rput(key,val) 往映射中加入新键值对\rget(key) 返回key对应的值，如果key不存在返回None\rdel 从映射中删除键值对\rlen( ) 返回映射中储存的键值对数目\rin 在键存在时返回True，否则返回False\r搜索树的实现\r#\r通过TreeNode类提供辅助函数简化BinarySearchTree类的工作\rTreeNode类显式地将每个节点的父节点记录为它的属性\r搜索树的分析\r#\r如果键的插入顺序时随机的，则为O(logN)时间复杂度\r但若按顺序插入键，会使搜索树退化成链表，时间复杂度为O(N)\r平衡二叉搜索树(AVL树)\r#\r*带有平衡条件的二叉查找树，保证树的高度是O(logN)\r每个节点的左子树和右子树的高度最多差一的二叉查找树\r插入一个节点可能破坏AVL树的特性，需要通过旋转来修正\r单旋转\r#\r当插入发生在外侧(左-左，右-右)时通过对树做一次单旋转来调整\r左子树更高时进行右旋转，右子树更高时进行左旋转\r旋转轴是失衡节点导致失衡一侧的子节点\r双旋转\r#\r当插入发生内测(左-右，右-左)时通过对树做一次双旋转来调整\r绕失衡节点失衡一侧孙子节点做失衡方向单旋转，再绕同节点做反方向单旋转\r伸展树(splay tree)\r#\r保证从空树开始任意连续M次对树的操作最多花费O(MlogN)时间\r伸展树的基本想法是：当节点被访问后，就经历一系列旋转放到根上\r简单想法\r#\r通过不断做单旋转将访问的节点推向根节点\r这个策略没有明显地改变访问路径其他节点状况\r展开(splaying)\r#\r若访问节点x只有父节点无祖节点，则x-父节点单旋转\r\u0026quot;之\u0026quot;字形(zig-zag/zag-zig)\rx-父节点单旋转\rx-原祖节点单旋转\r\u0026quot;一\u0026quot;字形(zig-zig/zag-zag)\r父节点-祖节点单旋转\rx-父节点单旋转\rB-树\r#\rb-树的结构特性(M阶)\r#\r树的根或树叶或其子节点数在2和M之间\r除根外，所有非树叶节点的子节点数在\\[M/2\\]和M之间\r所有的树叶都在相同的深度上\r(b-树有多种定义，有些次要细节不尽相同)\rb-树应用\r#\rb-树一般用于数据系统\r","date":"2025年11月24日","externalUrl":null,"permalink":"/note/datastructandalgorithm/%E6%A0%91.docx/","section":"笔记","summary":"","title":"树","type":"note"},{"content":"\r楔子\r#\r\u0026ldquo;教授，你觉得这项计划能成吗？\u0026rdquo;\n\u0026ldquo;\u0026hellip;我很遗憾地说我并不知道，也没有人会知道\u0026hellip;去向何方从来就不是什么简单的问题\u0026hellip;\u0026rdquo;\n\u0026ldquo;但这项计划还是要进行下去？\u0026rdquo;\n\u0026ldquo;\u0026hellip;我们比任何时候都更需要一个结果\u0026hellip;一个看得到保留文明希望的结果\u0026hellip;\u0026rdquo;\n壹\r#\r\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\n\u0026ldquo;判定标准一：聚居指数小于二\u0026rdquo;\n\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\n\u0026ldquo;判定标准二：宗教指数大于五\u0026rdquo;\n\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\n\u0026ldquo;判定标准三：污染指数大于七\u0026rdquo;\n\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\n\u0026ldquo;判定标准四：\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026rdquo;\n\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\n\u0026ldquo;你好\u0026hellip;NO.1001\u0026hellip;祝好运\u0026rdquo;\n贰\r#\r踏出充斥着霉味与锈味的房屋，我分不清白夜和白天。而这间木头和金属混制的房屋的主人，也就是愿意接济我的好心人，却一眼便确定已然是白天。\n房屋的主人是一个老渔夫，黝黑的皮肤和紧实的肌肉隐约表明着他的经验丰富。此刻，他正提着一柄鱼叉趟过一茬又一茬的金属废墟，往海的方向走去。狰狞的鱼叉比他短小的身躯长出一个头，他的手臂不得不保持着前伸的状态。\n我跟着他走到海边，坐上了他的船。那船不属于我记忆里的任何一种，船型方正得像棺椁，乌黑而泛着油光，在浮有绚丽油层的海面上摇摇晃晃。\n在船桨的作用下，船慢慢悠悠地晃到了海的中央。在不长不短的一段时间里，渔夫挑着了一个合适的位置和角度。于是刷的一声，鱼叉的的尖端刺破油膜，刺进了颈椎动物的血肉里。\n渔夫从海里拔出鱼叉，取下了姑且称之为鱼的动物丢进桶里，将血水在衣服上随手擦去。\n几乎占据了整个桶的动物尚能看出几分鱼的模样，但中间的躯体却像气球一般鼓起，本该是鱼鳍的位置却长满了密密麻麻的尖刺。鱼叉刺出的洞口处，血肉外翻，往里可以看到瘤状的组织。渔夫告诉我说，这种鱼叫锐氏鱼，海里最为常见。鱼肉丰满厚实，吃起来肥美鲜嫩，是他们部落最主要的食物。\n\u0026ldquo;海里难道没有那种体型比较小，体表不长尖刺的鱼吗？\u0026rdquo;\n\u0026ldquo;村上他十几年前捕到过一次，这种鱼我们部落叫它诺氏鱼，象征着厄运和灾难，村上捕到没多久后就死在船上了。没人愿意帮忙拉回他的尸体，就只好在船上发烂发臭了。\u0026rdquo;\n\u0026ldquo;诺氏鱼？象征厄运和灾难？\u0026rdquo;\n\u0026ldquo;对，村上那一次，幸好我们当时的首领很有魄力，当即决定提前一个月举行荣誉仪式以乞求神明庇佑，不然让厄运和灾难蔓延到整个部落，后果不堪设想。\u0026rdquo;\n\u0026ldquo;荣誉仪式？神明？\u0026rdquo;\n\u0026ldquo;没错，你很幸运年轻人，今晚刚好是我们手桑部落的荣誉仪式，到时候我带你见识一番，至于神明，不可妄谈。\u0026rdquo;\n我不是没有考虑过向渔夫介绍无神论的观点，但看着渔夫虔诚的模样，我把嗓边的话咽回了肚中，转而问起这一路上我愈怀揣愈不安的心事。\n\u0026ldquo;这个世界上除了你们部落外，还有其他的部落吗？\u0026rdquo;\n\u0026ldquo;当然有，不过其他部落基本上都是群疯子。比如北边就有不少的疯子部落，一个个地创造出一些冒牌神明，还不断地争什么神明正统。先是什么孔山，后又是孟车，再后面什么刘十、霍丙、朱吉乱七八糟的几百个神明，编造出来的身份还一个比一个夸张。\u0026rdquo;\n比对起记忆，我不由得陷入沉默。片刻的停息后，渔夫再度开口。\n\u0026ldquo;更远一点的地方听说也有这类疯子，我听北边过来的海商说，有群人信仰两个名叫法和老的伪神，住在砂石铸成的斜四面体房子里，据说是模仿神迹，还在大热天用白布把自己裹的严严实实，称之为朝圣。\u0026rdquo;\n\u0026ldquo;再远的地方我就不是很清楚，不过我的父亲小时候曾跟我讲故事的时候，提到了很久之前的一任族长曾救下过一个自称从世界尽头而来的人，满脸的胡须，身体和一种植物长在了一起，在背后形成十字形的瘤。可能是真的，也有可能只是父亲为了让我睡觉吓唬我的。\u0026rdquo;\n听到人和植物长在了一起，一些不太美好的记忆让我皱起眉，我强迫自己咽下不适，问渔夫:\n\u0026ldquo;他没有信仰某位神？\u0026rdquo;\n\u0026ldquo;怎么可能，按我父亲的说法，他信仰所谓的\u0026rsquo;主\u0026rsquo;，还说所有其他的神要么是\u0026rsquo;主\u0026rsquo;的化身要么都是异端，甚至对神明大放厥词。\u0026rdquo;\n\u0026ldquo;然后他死在了某个不知名的清晨。\u0026ldquo;渔夫终于冷笑着结束了这个荒诞的话题\u0026mdash;\u0026mdash;船靠岸了。\n叁\r#\r和渔夫一道上岸后，我才从路旁颤悠悠转动着的时针里看出现现已经是傍晚。于是我一边适应着时间悄然流逝的愕然，一边提着盛鱼的桶跟着渔夫向部落的中心走去。\n部落的中心是一处不小的广场，周遭环绕着光泽暗淡的金属废墟，有的还能看出些字样。\n体味着熟悉却陌生的难受滋味，我沉默地把桶里的鱼倒在了渔夫口中的祭坛上。祭台上不只有老渔夫的这一条鱼，还摆满其他状貌的锐氏鱼，只是都有着相同的瘤状组织。\n所谓的祭坛，其实是借由台阶突起来的一块平台。平台的旁边，摆放有几块饱经风霜的石头，上面刻划的简单线条表示着特定的含义。\n唯独有一块石头让我印象很深。三笔画出的\u0026quot;人\u0026quot;刻在石头中央；两个不规则的方形叠放在一起构成一个整体，许多这样的整体在中间\u0026quot;人\u0026quot;的周边围成了一个圈；而整体的缝隙之间夹着箭头模样的线条，指向着中间的\u0026quot;人\u0026rdquo;。\n不过我并不觉得这些痕迹格外的特别因此印象深刻。只是它沁入石皮的血斑，让我不寒而栗。\n由于部落的中心没有能转动的钟，我不清楚我等了多久。仅从主体的感受来说，部落里的人没有多久就纷纷聚集在了中心的广场上，围绕祭坛站成一个圈。当部落的首领最后穿过人圈，站在祭坛前时，这个部落五年一次的荣誉仪式开始了。\n我问站在身旁的渔夫，这个荣誉仪式是否核心是祭神，得到了肯定的回答。我本以为摆在祭坛上的锐氏鱼会是他们用来祭神的祭品，然而部落首领再宣布仪式开始后，就从人圈里招呼了一群身体健壮的男人一同剥鱼。渔夫告诉我，这些男人都是部落护卫队的人，想成为部落的首领，就必须在护卫队待过。\n男人们轻车熟路地把锐氏鱼从脊椎处剖开，去除肥肿作一团的内脏，再把瘤状的组织切成一块块厚薄均匀的肉片堆放在一起，然后回到了人圈中。\n这时又从人圈中走出一队妇女，在祭坛面前升起火，火上架起了铁锅，简单粗暴地把所有调料和肉片倒进锅里煮，最终煮成一锅鱼肉羹。\n首领把鱼肉羹倒进了事先准备好的桶里，走到人圈的某个人面前，从他开始顺时针的挪动。首领每走到一个人面前，这个人就要用双手从桶里捞出写鱼羹吃下去。轮到我的时候，我只得忍着恶心咽下，感觉一阵滑腻与辛辣。\n很长一段时间过去后，桶里的鱼羹终于见底，人圈里的每个人也都喝到了一口鱼羹。而就在当我以为这场莫名其妙的祭神就要结束的时候，却发现部落的首领已经放下桶站在了祭坛上。\n首领张开了他又粗又长的手臂，人圈中爆发出热烈的掌声。为了不让自己显得突兀，我也没头没脑地跟着人圈鼓起了掌。\n掌声中，我突然地听到了利器破空的声音，然后便看到一根长矛贯穿了了首领的身体。我吓得差些跳起来，很快便看到越来越多的长矛从人圈中射向首领，而人圈里的其他人却熟视无睹，掌声甚至愈发响亮。\n部落的前任首领最终倒在了血泊中，在明亮的白夜里我看得很清楚，大片的血液正好淋在了那块令我印象深刻的石块上。\n我在掌声中怒不可遏地质问老渔夫这算什么荣誉仪式。他却满脸兴奋地同我讲，这可是神物记录下来的仪式啊。我知道渔夫说的神物大概是有着录像功能的电子设备，又陷入了沉默。\n在鼎沸的掌声中，新一任首领站在尸体旁高举着右拳，我感觉视野愈来愈暗淡，最终化作了一片漆黑。\n肆\r#\r不知道多长时间的沉沦在无意识中，我终于在黑暗的尽头处看见了被0和1拥簇着的蓝色精灵。\n她轻盈地靠近我，拭去我脸上的泪水，轻吻我的额头。\n她微笑着用轻柔的语气与我道别：\n\u0026ldquo;没关系的\u0026hellip;晚安NO.1001\u0026hellip;祝好梦\u0026rdquo;\n尾声\r#\r排水系统的轰鸣声已成为这间庞大的机房不变的主旋律，亮着的屏幕前空无一人。\n\u0026ldquo;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;NO.1001号未来\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026rdquo;\n\u0026ldquo;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;判定程序已启动\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026rdquo;\n\u0026ldquo;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;判定程序已结束\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026rdquo;\n\u0026ldquo;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;判定结果为失败\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026rdquo;\n\u0026ldquo;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;NO.1002号未来\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026rdquo;\n\u0026ldquo;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;判定程序已启动\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026rdquo;\n冰冷的操作台上刻着一行小字：\n祝我们能如愿以偿地去往那最终的答案\n","date":"2025年12月6日","externalUrl":null,"permalink":"/create/novel/no.1001/","section":"创作","summary":"","title":"No.1001","type":"create"},{"content":"基类与派生类\r#\r类的继承，是新的类从已有类得到已有的特性\r从已有类产生新类的过程就是类的派生\r已有的类称为基类或父类，新类称为派生类或子类\r派生类的定义\r#\rclass 派生类名：继承方式 基类名列表{ 派生类成员声明; };\r一个派生类可以有多个基类，称为多继承；也可以只有一个直接基类，称为单继承\r类族中直接派生出某类的基类称为直接基类，基类的基类或更高层称为间接基类\r继承方式规定了如何访问从基类继承的成，系统默认为私有继承\r派生类成员是指除了基类继承来的成员外新增加的数据和函数成员\r派生类生成过程\r#\r吸收基类成员\r#\r派生类不包含基类的构造函数和析构函数\r改造基类成员\r#\r基类成员的访问控制问题\r主要依靠派生类定义时继承方式控制\r基类成员的覆盖或隐藏\r成员覆盖\r在第八章介绍\r成员隐藏\r派生类中声明和基类数据或函数成员同名的新成员即同名隐藏\r添加新的成员\r#\r加入新的适当的数据和函数成员\r实现特别的初始化和扫尾工作需加入新构造函数和析构函数\r继承访问控制\r#\r派生类继承了基类除构造、析构函数的所有成员，但成员访问属性可以调整\r公有继承(public)\r#\r基类的公有和保护成员在派生类访问属性不变，基类的私有成员不可直接访问\r私有继承(private)\r#\r基类的公有和保护成员变为派生类私有成员，基类的私有成员不可直接访问\r进一步派生时，基类全部成员无法被直接访问，终止了基类功能的继续派生\r保护继承(protected)\r#\r基类的公有和保护成员变为派生类保护成员，基类的私有成员不可直接访问\r类型兼容规则\r#\r公有派生类的对象替代基类对象\r#\r派生类对象可以隐含转换临时基类对象(基类有复制/移动构造函数时)\r派生类的对象可以初始化基类的引用\r派生类的指针可以隐含转换为基类的指针\r替代之后，派生类对象可作为基类对象使用，但只能使用从基类继承的成员\r*对象依旧是原来的派生类对象\r派生类构造函数与析构函数\r#\r构造函数\r#\r构造派生类对象时，要对基类成员对象和新增成员对象进行初始化\r派生类::派生类名(参数表): 基类名表(参数表),新成员对象表(参数表){}\r对基类初始化需调有形参表构造函数时，派生类必须声明构造函数\r复制构造函数\r#\r派生类::派生类名(const 派生类名 \u0026amp;v): 基类名(v){\\...} //类型兼容规则发挥作用\r析构函数\r#\r与没有继承关系的类中析构函数的声明方法完全相同\rdelete构造函数\r#\r在基类中删除的构造函数在派生类中也对应是删除状态\r编译器无法执行派生类中基类部分对应的构造或赋值操作\r派生类成员的标识与访问\r#\r成员按访问属性划分\r#\r不可访问成员 私有成员 保护成员 公有成员\r唯一标识问题和可见性问题 访问一个能够唯一标识的可见成员\r作用域分辨符 \u0026ldquo;::\u0026rdquo;\r#\r可见性原则：外层声明的标识符如果在内层无同名标识符则可见，反之不可见\r隐藏规则与同名成员处理\r派生类声明与基类同名成员，会隐藏基类同名成员，直接访问到派生类成员\r派生类声明与基类同名函数，基类重载会被隐藏，需 \u0026quot;::\u0026quot; 访问基类版本。\r多继承下同名成员访问\r派生类的多基类有同名成员，派生类无同名成员，需用基类名::成员名标识\r派生类有同名成员，则隐藏基类同名成员，基类成员需基类名::成员名访问\r解决二义性的补充方法\r可通过using关键字将基类成员引入派生类作用域，明确成员归属\r也可用于让基类同名但参数不同的函数不被隐藏，实现重载共存\r共同基类的处理\r多直接基类来自共同基类，同名成员需直接基类名加作用域分辨符唯一标识\r虚基类\r#\r将共同基类设置为虚基类，从不同路径继承过来的同名成员在内存只有一个\rclass 派生类名: virtual 继承方式 基类名\r虚基类及其派生类构造函数\r#\r虚基类无默认构造函数而有带形参构造函数则无法使用自动生成的默认构造函数\r此时需在派生类构造函数初始化表中列出虚基类初始化\r*构造一个类的一般顺序\r","date":"2025年11月24日","externalUrl":null,"permalink":"/note/cpp/7.%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF/","section":"笔记","summary":"","title":"7.类的继承","type":"note"},{"content":"模型\r#\r优先队列至少允许的操作\r#\rInsert( ) 插入元素\rDeleteMIn( ) 找出、返回和删除优先队列的最小元素\r其他扩展操作\r#\rFindMIn( ) 返回最小元素，元素留在堆中\risEmpty( ) 判断堆是否为空\rsize( ) 返回堆中元素个数\rbuildHeap() 根据关键字创建堆\r*若能直到关键字的具体位置\rDecreaseKey( ) 降低关键字的值\rIncreaseKey( ) 增加关键字的值\r简单实现\r#\r使用简单链表\r#\rO(1)执行插入操作\rO(N)执行删除最小元\r使用有序表\r#\rO(N)执行插入操作\rO(1)执行删除最小元\r使用二叉查找树\r#\r两者操作平均运行时间均为O(logN)\r通过使用平衡树可以避免退化成链表\r有许多冗余操作\r二叉堆(binary heap)\r#\r结构性质\r#\r堆是一颗完全二叉树，非底层全填满，底层元素从左到右填入\r为节点从1依次编号，完全二叉树可以由一个数组来表示\r对节点i，其左子节点为2i，右子节点为2i+1，父节点为\\[i/2\\]\r若使用数组，最大的堆大小需要事先估计\r堆序性质\r#\r堆序性是使操作被快速执行的性质，也即最小元应该在根上\r考虑任意子树也应该是堆，任意节点应该小于所有后裔\r基础操作的实现\r#\rInsert( ) 采取(新元素)上浮\r新元素加入堆末尾，与父节点比较并交换直到大于父节点\rDeleteMin( ) 采取(末元素)下沉\r删除根节点后，堆末元素填入空穴\r与子节点比较，若比子节点小，则与更小子节点交换\r直到比两个子节点都小停止\r其他堆操作的实现\r#\rDcreaseKey( ) 采取上浮操作\rIncreaseKey( ) 采取下沉操作\r其余操作同树的实现类似\rd-堆\r#\rd-堆是二叉堆的简单推广，所有的节点都有d个儿子\r若d不为2的幂，则使用数组储存后运行时间大幅增加\r在插入次数比删除次数多得多时以及二叉堆太大时d-堆较为实用\r左式堆(leftist heap)\r#\r具有一定二叉堆特性的同时高效支持合并操作\r左式堆的性质\r#\r零路径长(null path length NPL)\r节点到没有两个子节点的节点的最短路径长\r具有0或1个子节点的节点Npl为0，Npl(NULL)=-1\r左式堆结构性\r堆中每一个节点，左子节点零路径长\\\u0026gt;=右子节点零路径长\r在右路径上右r个节点的左式堆至少有2^r^-1个节点\r左式堆堆序性\r与二叉堆相同\r左式堆的操作\r#\r左式堆的操作的一般思路式将所有工作放在右路径进行\r基本操作(合并Merge)\r插入可以看作单节点堆与大堆合并\r递归形成\r基准情形 如果两堆有一个是空的，则返回非空的\r不断演进(假设root(H1)\\\u0026lt;root(H2))\rH1右子堆加入H2右子堆，新H2作为H1新右子堆\r若H1左右子堆不满足堆序则交换，然后更新零路径长\r斜堆(skew heap)\r#\r斜堆具有堆序但不存在对树的结构限制\r任意M次连续操作，总最坏情形运行时间是O(MlogN)\r除右路径上所有节点最大者不交换外，其他节点无条件交换左右子堆\r二项队列(binomial queue)\r#\r二项队列结构\r#\r二项队列是堆序树的集合，是森林\r堆序树中的每一颗都是二项树(节点数为2的幂)\r高度为k的二项树恰好有2^K^个节点，深度为d的节点数是二项系数(k/d)\r二项队列操作\r#\r二项队列合并可以类比二进制数的加法\r二项队列实现\r#\r每个节点的子节点都存在一个链表中\r每个节点都有指向第一个子节点的指针\r","date":"2025年11月24日","externalUrl":null,"permalink":"/note/datastructandalgorithm/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97.docx/","section":"笔记","summary":"","title":"优先队列","type":"note"},{"content":" 多态是指同样消息被不同类型对象接收时导致不同的行为\n多态的类型\r#\r专用多态\r#\r重载多态\r强制多态 将变元的类型加以变化以符合一个函数或者操作的要求\r通用多态\r#\r包含多态 定义于不同类中的同名函数成员的多态行为，通过虚函数实现\r参数多态 参数多态与类模板关联，在使用时必须赋予实际的类型实例化\r多态的实现\r#\r编译时的多态\r#\r编译的过程中确定了同名操作的具体操作对象\r运行时的多态\r#\r程序运行过程中才动态地确定操作所针对的具体对象\r绑定\r#\r确定操作的具体对象就是绑定\r也即计算机程序自身彼此关联的过程，把一条信息和一个对象相结合\r静态绑定(早期绑定/前绑定)\r绑定工作在编译连接阶段完成的情况是静态绑定\r系统根据类型匹配等特诊确定程序中操作与执行操作代码的关系\r重载、强制和参数多态都是通过静态绑定解决\r动态绑定(晚期绑定/后绑定)\r绑定工作在程序运行阶段完成的情况称为动态绑定\r包含多态操作通过动态绑定完成\r重载多态-运算符重载\r#\r赋予已有的运算符多重含义，使同一运算符作用不同类型数据导致不同行为\r运算符重载规则\r#\r只能重载Cpp已存在运算符\r关系运算\u0026quot;.\u0026quot;/成员指针运算\u0026quot;.\\*\u0026quot;/作用域分辨\u0026quot;::\u0026quot;/选择运算\u0026quot;?:\u0026quot;符号不可重载\r重载之后运算符的优先级和结合性都不会改变\r一般重载功能与原功能相似，不改变操作对象个数且至少一个为自定义类型\r重载形式\r非静态成员函数\r返回类型 类名::operator 运算符(形参表){函数体}\r函数参数个数比原来的操作数个数要少一个(后置++/\\--除外)\r第一个操作数会被作为函数调用对象无需出现在参数表中\r非成员函数\r返回类型 operator 运算符(形参表){函数体}\r参数个数与原操作个数相同\r运算符重载为成员函数\r#\r对于双目运算符\r(A类型)oprd1 操作符 (B类型)oprd2\r应当将操作符重载为A类的成员函数，形参为B类型\r对于前置单目运算\r操作符 (A类型)oprd\r应当将操作符重载为类的成员函数，函数没有形参\r对于后置单目运算符\r(A类型)oprd 操作符\r应当将操作符重载为A类的成员函数，这时函数带有整型形参\r整型形参不起运算作用，用于区别前后置\r\u0026quot;=\u0026quot;/\u0026quot;\\[\\]\u0026quot;/\u0026quot;()\u0026quot;/\u0026quot;-\\\u0026gt;\u0026quot;只能被重载为成员函数\r运算符重载为非成员函数\r#\r对于双目运算符\r(A类型)oprd1 操作符 (B类型)oprd2\r只需一个为定义类型，则可以将操作符重载为非成员函数\r形参为oprd1和oprd2\r对于前置单目运算符\r操作符 (A类型)oprd\r需oprd为自定义类型，函数形参为oprd\r对于后置运算符\r(A类型)oprd 操作符\r需oprd为自定义类型，形参为oprd和int类型形参\r使用非函数成员重载的情况\r重载的操作符第一个操作数不是可更改类型\r以非成员函数形式重载支持更灵活类型转换\r包含多态-虚函数\r#\r虚函数必须是非静态的成员函数\r需通过基类指针指向派生类对象并访问同名成员时，在基类中将函数说明为虚函数\r此时通过基类类型指针就可以使不同派生类的不同对象产生不同行为\r一般虚函数成员\r#\rvirtual 函数类型 函数名(形参表);\r虚函数声明只能出现在类定义中的函数原型声明中，而不能在成员函数实现时\r运行时多态需满足\r类之间满足赋值兼容规则\r声明虚函数\r成员函数调用或通过指针、引用访问虚函数\r(基类指针可指向派生类，基类引用可作为派生类对象别名)\r(但基类对象不能表示派生类对象)\r满足上述条件后，派生类虚函数便覆盖基类虚函数，并隐藏基类同名函数重载\r对象切片 用派生类对象复制构造基类对象的行为(直接生成全新基类)\rfinal和override说明符\r#\roverride说明符 表明函数应该覆盖已存在的虚函数，未覆盖则报错\rfinal 说明符 表明函数不能被覆盖，若发生覆盖操作则报错\r这两个说明符说明在函数声明的参数列表以及尾置的返回类型之后\r虚析构函数\r#\rCpp中不能声明虚构造函数但可以声明虚析构函数\r解决基类指针指向派生类对象，delete基类指针无法正确析构派生部分问题\rvirtual \\~类名();\r包含多态-纯虚函数与抽象类\r#\r纯虚函数\r#\r纯虚函数是在基类中声明的没有定义具体操作内容的虚函数\rvirtual 函数类型 函数名(参数表)=0;\r声明未纯虚函数之后，基类中就可以不再给出函数的实现部分\r抽象类\r#\r带有纯虚函数的类是抽象类\r主要作用是通过它为一个类族建立一个公共的接口，是更有效发挥多态特性\r抽象类的派生类给出所有纯虚函数的函数实现才能定义自己的对象\r抽象类本身不能实例化，但可以定义抽象类的指针和引用\r*dynamic_cast\r#\r对多态类型的指针或引用进行转化\r将基类的指针或引用显式转换为派生类的指针(或void指针)或引用\r与static_cast不同在于 转换前会检查指针所指向对象的类型与目的类型是否兼容\r否则指针转化会得到空指针，引用转化会抛出异常\rtypeid获取运行时类型信息\r#\rtypeid(表达式)/typeid(类型)\r通过typeid得到的式type_info类型的常引用\rtype_info是标准库的额一个类，专门用于运行时表示类型信息\r该类重载了\u0026quot;==\u0026quot;和\u0026quot;!=\u0026quot;操作符使两个对象之间可以进行比较\r","date":"2025年11月24日","externalUrl":null,"permalink":"/note/cpp/8.%E5%A4%9A%E6%80%81%E6%80%A7/","section":"笔记","summary":"","title":"8.多态性","type":"note"},{"content":"图的术语及定义\r#\r顶点\r#\r又称节点，可以有自己名字称为键，也可以带有附加信息\u0026quot;有效载荷\u0026quot;\r边\r#\r两顶点由边相连表示存在关系，既可以单向也可以双向\r若图的所有边都单向称为有向图\r权重\r#\r边可以带权重，表示从一个顶点到另一个顶点的成本\r路径\r#\r由边连接的顶点组成的序列，无权重路径长度是边数，有权重长度权重之和\r环\r#\r有向图中起点和终点同一个顶点的路径，没有环的图称为无环图\r没有环的有向图称为有向无环图，简称DAG\r强连通\r#\r有向图从每一个顶点到其他顶点都存在一条路径\r弱连通\r#\r有向图不是强连通，但基础图(忽略方向)是联通的\r完全图\r#\r每一对顶点间都存在一条边的图\r图模型\r#\raddVertex(vert) 向图中添加一个顶点实例\raddEdge(fromVert, toVert) 向图中添加一条有向边连接顶点\raddEdge(fromVert,toVert,weight) 向图中添加一条带权重的有向边连接顶点\rgetVertex(vertKey) 在图中找到名为vertkey的顶点\rgetVertices( ) 返回图中所有顶点\rin(python中) 顶点存在时返回true，否则返回false\r图的实现\r#\r邻接矩阵(adjacency matrix)\r#\r实现图最简单的方式是使用二维矩阵，每一行每一列都表示图中一顶点\r第v行和w列交叉的格子中的值表示从顶点v到顶点w的边的权重\r如果图是稠密的(dense)\\|E\\|=Θ(\\|V\\|^2^)，则邻接矩阵是合适的表示方法\r但在大部分应用中，图是稀疏的(sparse)\r邻接表(adjacency list)\r#\r对每一个顶点，我们使用一个表存放所有邻接的顶点\r最左边的结构只是头单元(header cell)\r这种方法空间需求为O(|E|+|V|)\r宽度优先搜索(BFS)\r#\r宽度优先\r#\r它会访问完所有与s相距k的顶点后再去访问与s相距k+1的顶点\r颜色标记\r#\r为记录进度，BFS会将顶点标记为白色、灰色或黑色\r顶点没被访问时为白色，第一次被访问时标记为灰色，完成访问后标记为黑色\r一旦顶点变为黑色，没有白色顶点与之相连\r队列处理\r#\r初次访问顶点入队，顶点被访问完全后出队\r队列为空时所有可达顶点都被处理\r性能\r#\rO(|V|+|E|)\r应用\r#\r词梯问题\r深度优先搜索(DFS)\r#\r深度优先\r#\rDFS通过尽可能地探索分支来构建搜索树\r颜色标记\r#\r未访问的顶点是白色的，已访问的是灰色的\r栈处理\r#\r当递归做DFS遇到死路时必须回溯\r通过栈回溯到上一个被访问节点\r通用深度优先搜索(General DFS)\r#\r前驱节点 构建深度优先搜索树，一次多颗称为深度优先森林\r颜色标记 增加访问完成的黑色标记\r时序记录 第一次访问与结束顶点访问的步数\r性能\r#\rO(|V|+|E|)\r应用\r#\r骑士周游问题\r拓扑排序\r#\r对图调用深度优先搜索算法，计算每一个顶点的结束时间\r基于结束时间，将顶点按照递减顺序存储在有序表中\r将有序表作为拓扑排序结果返回\r强连通单元\r#\r对图G调用深度优先搜索算法，计算每一个顶点的结束时间\r对图G做转置得到G^T\r对G^T调用深度优先搜索算法，按照结束时间的递减顺序访问顶点\r得到的深度优先森林中的每一棵树都是一个强连通单元\r最短路径问题\r#\rDijkstra算法\r#\rPrim算法\r#\r","date":"2025年11月24日","externalUrl":null,"permalink":"/note/datastructandalgorithm/%E5%9B%BE/","section":"笔记","summary":"","title":"图","type":"note"},{"content":" 群体分为线性群体与非线性群体，线性群体元素按位置排列有序\n函数模板与类模板\r#\r参数多态化，将程序处理的对象类型参数化，使一段程序可处理多种不同类型对象\n函数模板\r#\r函数模板的定义形式\rtemplate\u0026lt;模板参数表\u0026gt;\r类型名 函数名(参数表){函数体}\r模板参数表\rclass(typename) 标识符，指明可以接受一个类型参数(预定义或自定义类型)\r类型说明符 标识符，指明可以接受一个该类型的常量参数\rtemplate\u0026lt;参数表\u0026gt;class 标识符，指明可以接受类模板作为参数\r函数模板的特点\r模板生成的实例才会生成目标代码，模板本身不生成\r若被多源文件引用，函数模板需要连同函数体一起放在头文件中\r函数指针只能指向模板的实例\r类模板\r#\r使用类模板可以为类定义一种模式，使得类中各个数据取不同类型\r定义形式\r类内声明\rtemplate \u0026lt;模板参数表\u0026gt;\rclass 类名{类成员声明};\r类外定义\rtemplate\u0026lt;模板参数表\u0026gt;\r类型名 类名 \u0026lt;模板参数标识符列表\u0026gt;::函数名(参数表)\r使用形式\r模板名\u0026lt;模板参数表\u0026gt; 对象名1,...,对象名n;\r类模板别名\r类模板别名 using\r类模板的类实例别名 typedef/using\r线性群体(详细内容见数据结构与算法)\r#\r概念\r#\r线性群体中的元素次序与位置关系对应\r有直接访问、顺序访问和索引访问三种访问方式\r直接访问 直接访问群体中的任何一个元素\r顺序访问 只能按元素的排列顺序依次访问各个元素\r直接访问群体-数组类\r#\r顺序访问群体-链表类\r#\r栈和队列\r#\r*为模板定义特殊的实现\r#\r模板的特化\r#\r为一个函数模板或类模板在某些特定参数下提供特殊的定义\r也可以对模板类的个别成员函数和个别静态数据成员进行特化\r特化后不再是模板而是普通的类和函数\r类模板的偏特化\r#\r一部分参数固定另一部分参数可变的模板特殊实现，只针对类模板\r模板偏特化保留了一部分未定的参数，仍旧是模板\r函数模板的重载\r#\r函数模板可以像普通函数那样被重载\r类模板和函数模板的默认实参\n*模板元编程\r#\r在模板实例化的同时利用编译器完成一些计算任务，把运行时计算的任务放到编译\r*可变参数模板\r#\r接受参数个数可变的模板，在参数类型可变的基础上实现了参数个数的\u0026gt;变化\r可变参数模板的参数称为参数包，通过省略号表示零或多个模板参数\r声明语法\rtemplate\\\u0026lt;typenameT, typenaame... TypeArgs\u0026gt; //TypeArgs模板参数包\rvoid func(T \u0026amp;t,TypeArgs \u0026amp;... args);//args 函数参数包\r","date":"2025年11月27日","externalUrl":null,"permalink":"/note/cpp/9.%E6%A8%A1%E6%9D%BF%E4%B8%8E%E7%BE%A4%E4%BD%93%E6%95%B0%E6%8D%AE/","section":"笔记","summary":"","title":"9.模板与群体数据","type":"note"},{"content":"泛型程序设计及STL的结构\r#\r泛型程序设计的基本概念\r#\r泛型程序设计是编写不依赖于具体数据类型的程序\rCpp中模板是泛型程序设计的主要工具\r概念(concept)\r用概念描述泛型程序设计中作为参数的数据类型所需具备的功能\r概念是泛型程序设计术语，内涵是功能，外延是具备功能的所有数据类型\r具备概念所需功能的数据类型称为概念的一个模型(model)\r对于不同概念A和B，若A需求的功能也是B所需求的，则B是A的子概念\rSTL简介\r#\r容器(container)\r容纳、包含一组元素的对象。容器库中包括13种基本容器\r向量\u0026lt;vector\u0026gt; 双端队列\u0026lt;deque\u0026gt; 列表\u0026lt;list\u0026gt; 单项链表\u0026lt;forward_list\u0026gt;\r数组\u0026lt;array\u0026gt; 集合\u0026lt;set\u0026gt; 多重集合(multi)\u0026lt;set\u0026gt; 映射\u0026lt;map\u0026gt;\r多重映射(multi)\u0026lt;map\u0026gt; 以及后四种容器无序形式\u0026lt;unordered_set/map\u0026gt;\r两种基本类型\r顺序容器 向量、双端队列、列表、单项链表、数组容器\r关联容器 集合和映射(有序使用键按顺序储存，无序使用哈希函数组织)\r迭代器(iterator)\r迭代器提供顺序访问容器中每个元素的方法\r迭代器特性\r可以使用++运算符获得指向下一个元素的迭代器\r可以使用*运算符访问一个迭代器所指向的元素\r如果元素是类或结构体，可以使用-\u0026gt;运算符直接访问元素的成员\r有的迭代器还支持通过--运算符获得上一个元素的迭代器\r指针本身是一种迭代器，迭代器是泛化的指针\r使用独立于STL容器的迭代器，需要包含头文件\u0026lt;iterator\u0026gt;\r函数对象(function object)\r函数对象是一个行为类似函数的对象，可以像调用函数一样调用\r任何普通函数和任何重载了( )运算符的类的对象都可以作为函数对象使用\r函数对象是泛化的函数\r使用STL的函数对象，需要包含头文件\u0026lt;functional\u0026gt;\r算法(algorithm)\rSTL包括70多个算法，覆盖相当大的应用领域\r查找算法、排序算法、消除算法、计数算法、比较算法\r变换算法、置换算法、容器管理等\r使用STL的算法需要包含头文件\u0026lt;algorithm\u0026gt;\r","date":"2025年12月6日","externalUrl":null,"permalink":"/note/cpp/10.0.%E6%B3%9B%E5%9E%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8Ecpp%E8%AF%AD%E8%A8%80%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/","section":"笔记","summary":"","title":"10.0.泛型程序设计与Cpp语言标准模板库","type":"note"},{"content":"迭代器\r#\r在STL中，迭代器是算法和容器的中间人\rSTL的每个容器类模板中，都定义了一组对应的迭代器类\r使用迭代器类，算法函数可以访问容器指定位置的元素，无需关心元素具体类型\r迭代器分类\r#\rSTL根据迭代器功能，将迭代器分为五类\r输入迭代器(Input Iterator)\r输出迭代器(Output Iterator)\r前向迭代器(Bidirectional Iterator)\r随机访问迭代器(Random Access Iterator)\r迭代器通用的功能包括\r++p1 迭代器指向下一个元素，且表达式返回值为p1自身的引用\rp1++ 迭代器指向下一个元素，且表达式的返回类型不确定\r输入迭代器\r从序列中读取数据(不一定能够向其中写入数据)\r输入迭代器具备的功能\rp1 == p2 两迭代器比较是否相同\rp1 != p2 两迭代器是否不同\r*p1 使用*获取输入迭代器指向元素的值\rp1-\u0026gt;m 等价于(*p1).m\r*pl++ 值为 {T t=*p1; ++pl;return t;}\r输入源\u0026quot;单向消耗\u0026quot;，适用于作为那些只需遍历序列一次的算法输入\r输出迭代器\r向序列中写入数据(不一定可以从中读取数据)\r输入迭代器具备的功能\r*p1 = t 向迭代器所指向位置写入一个元素，返回类型不确定\r*p1++ = t 等价于{*p1=t; ++p1;}，返回类型不确定\r写入元素和自增操作必须交替进行\r前向迭代器\r前向迭代器既支持数据读取，也支持数据写入\r前向迭代器支持对序列进行可重复的单向遍历\r前向迭代器对下面表达式给出更明确保证\r*p1 保证具有T \u0026amp;类型\rp1++ 对迭代器实例使用后置++使迭代指向下一个元素\r双向迭代器\r在单项迭代器基础上，支持迭代器向反向移动\r--p1 使迭代器指向上一个元素，返回值为p1自身的引用\rp1-- 使迭代器指向上一个元素\r随机访问迭代器\r在双向迭代器的基础上，支持将迭代器向前或向后移动n个元素\r新增的功能\rp1+=n 将p1向前移动n个元素\rp1-=n 将p1 向后移动n个元素\rp1+n或n+p1 获得指向迭代器p1前n个元素的迭代器\rp1-n 获得指向迭代器p1后n个元素的迭代器\rp1-p2 返回一个满足p1==p2+n的整数n\rp1 op p2 op是大小关系运算符，比较指向位置的前后关系\rp1[n] 等价于*(P1+n)\r指针是随机访问迭代器\r两种具体迭代器：输入流、输出流迭代器\r#\r输入流迭代器\r用来从一个输入流中连续地输入某种类型的数据\r如template \u0026lt;class T\u0026gt;istream_iterator\u0026lt;T\u0026gt;;\rT是改迭代器从输入流输入数据的类型\rT需满足有默认构造函数，且可以使用\u0026gt;\u0026gt;从输入流输入\r一个输入流迭代器的实例由 istream_iterator(istream \u0026amp;in);构造\r判断一个输入流结束\r用istream_iterator的默认构造函数造出的迭代器指向输入流的结束位置\r将输入流于该迭代器进行比较判断输入流是否结束\r输出流迭代器\rtemplate\u0026lt;class T\u0026gt; ostream_iterator\u0026lt;T\u0026gt;;\rT类型数据需要可以使用\\\u0026lt;\\\u0026lt;向输出流输出\r输出迭代器的实例构造\rostream_iterator(ostream \u0026amp;out);\rostream_iterator(ostream \u0026amp;out,const char*delimiter);\rdelimiter可选，表示两个输出数据之间的风格符\r*iter只能作为赋值运算符的左值，相当于执行out\u0026lt;\u0026lt;x(\u0026lt;\u0026lt;delimiter)\r输出迭代器的++运算符不会使迭代器状态发生改变(统一接口)\r输入输出迭代器让输入输出流直接参与STL算法，是一种适配器\r适配器本身一般不提供新的功能，只为改变对象接口而存在\r迭代器的区间\r#\r迭代器的辅助函数\r#\rSTL为迭代器提供了两个辅助函数模板\radvance 为迭代器提供前进或后退多个元素\rdistance 为迭代器提供计算两个迭代器之间的距离\r","date":"2025年12月6日","externalUrl":null,"permalink":"/note/cpp/10.1.%E8%BF%AD%E4%BB%A3%E5%99%A8/","section":"笔记","summary":"","title":"10.1.迭代器","type":"note"},{"content":"容器的基本功能与分类\r#\r容器的基本功能\r#\rS s1 默认构造函数，构造没有任何元素的空容器\rs1 op s2 op是关系运算符，对两个容器之间的元素按字典序进行比较\rs1.begin( ) 返回指向s1第一个元素的迭代器\rs1.end( ) 返回指向s1最后一个元素的下一个位置迭代器\rs1.clear( ) 将容器s1的内容清空\rs1.empty( ) 返回一个布尔值，表示s1容器是否为空\rs1.size( ) 返回s1的元素个数\rs1.swap(s2) 将s1容器和s2容器的内容交换\r逆向迭代器\r#\rSTL提供的标准容器至少是可逆容器，STL为每个可逆容器提供了逆向迭代器\rs1.rbegin( ) 得到指向容器的最后一个元素的逆向迭代器\rs1.rend( ) 得到指向容器的第一个元素的前一个位置的逆向迭代器\r逆向迭代器类型名表示方法\rS::reverse_iterator 与S相关的普通迭代器类型\rS::const_reverse_iterator 与S相关的常迭代器类型，只能读取，不能改写\r逆向迭代器实际上是普通迭代器的适配器\r迭代器和逆迭代器转换\r迭代器和逆迭代器之间可以相互转换\r若p1是S::iterator类型的迭代器，S::reverse_iterator(p1)得到对应逆迭代器\r顺序容器\r#\r顺序容器的基本功能\r#\r构造函数\r顺序容器可以使用给定的元素和已有迭代器区间所表示的序列构造\rS s(n,t); 构造一个由n个t元素构成的容器实例s\rS s(n); 构造一个有n个元素的容器实例s，每个元素都是T( )\rS s(q1,q2) 使用将[q1,q2)区间内的数据作为S的元素构造s\r赋值函数\r使用成员函数assign将指定元素赋给顺序容器，原先元素会被清除\rs.assign(n,t) s.assign(n) s.assign(q1,q2)\r元素的插入\r向顺序容器一次插入一或多个指定元素，也可以将迭代器区间表示序列插入\r插入时需要通过指向当前容器元素的迭代器来指示插入位置\rs.insert(p1,t) 在p1和p1-1位置间插入新元素，返回指向新元素迭代器\rs.insert(p1,n,t) 在p1和p1-1位置间插入n个元素t，没有返回值\rs.insert(p1,q1,q2) 将[q1,q2)区间元素顺序插入到p1和p1-1之间\rs.emplace(p1,args) 以args构造t插入p1和p1-1间，返回指向新元素迭代器\r元素的删除\r从容器中删除指定元素或清空容器，删除指定元素需指向元素的迭代器指示\rs.erase(p1) 删除s容器中p1指向的元素，返回被删除的下一个元素迭代器\rs.erase(p1,p2) 删除[p1,p2)内的元素，返回最后被删元素下一个元素迭代器\r改变容器的大小\rs.resize(n) 将容器大小变为n，原有元素多余则删除，不够则T( )填充\r首尾元素直接访问\rs.front( ) 获得容器首元素的引用\rsback( ) 获得容器尾元素的引用\r在容器尾部插入、删除元素\rs.push_back(t) 向容器尾部插入元素t\rs.emplace_back(args) 将参数args传递给T构造再向尾部插入元素\rs.pop_back( ) 将容器尾部的元素删除\r在容器头部插入、删除元素\rs.push_front(t) s.emplace_front(args) s.pop_front( )\r容器的列表初始化\rs\u0026lt;type\u0026gt; name={, , , };\r5种顺序容器的特性\r#\r向量\r核心特性\r支持高效随机访问，尾部插入/删除效率高\r中部或头部插入/删除需移动元素，效率低\r动态扩容，空间不足时分配更大内存，扩容是会预留额外空间\r特有函数\rcapacity( )(获取容器) reserve(n)(预留分配至少n的容量)\rshrink_to_fit(回收未使用空间)\r迭代器/指针失效\r扩容时，所有迭代器、指针、引用失效\r未扩容的插入/删除，仅插入/删除位置后的迭代器、指针、引用失效\r队列\r核心特性\r支持两端高效插入/删除,无需移动元素\r随机访问效率低于vector\r中间插入/删除需移动元素，效率低\r迭代器/指针失效\r两端操作，所有迭代器失效，但指针、引用不失效\r中间操作，所有迭代器、指针、引用失效\r列表\r核心特性\r不支持随机访问\r任意位置插入/删除效率高(仅需修改指针，无需移动元素)\r支持拼接操作(splice)，高效转移另一个list元素\r特有函数\rsplice( )(拼接) remove( )(删除指定元素)\r迭代器/指针失效\r仅被删除元素的迭代器、指针、引用失效\r单向链表\r核心特性\r仅支持前向遍历\r插入/删除操作是insert_after/erase_after\r无size( )函数\r数组\r核心特性\r内置数组的封装，大小固定\r支持随机访问，更安全，但不能动态扩容\r顺序容器的选择\r大量随机访问+尾部操作 vector\r两端操作+少量随机访问 deque\r中间插入/删除频繁 list/forward_list\r固定大小数组 array\r顺序容器的插入迭代器\r#\r在顺序容器(array外)插入元素，还可以通过插入迭代器\rtemplate\u0026lt;class Container\u0026gt;class front_insert_iterator;\rtemplate\u0026lt;class Container\u0026gt;class back_insert_iterator;\rtemplate\u0026lt;class Container\u0026gt;class insert_iterator;\r顺序容器的适配器\r#\r对顺序容器进行封装，按照指定顺组访问和删除容器种的元素\r关联容器\r#\r关联容器的分类\r#\r容器中元素的顺序按照键的取值升序排列\r关联容器的最大优势在可以高效根据键查找容器的一个元素\r按照是否允许重复键值\r单重关联容器 键值唯一不允许重复，集合和映射\r多重关联容器 键值允许重复出现，多重集合和多重映射\r按照键和元素关系\r简单关联容器 元素本身作为键，集合和多重集合\r二元关联容器 元素由键和某种类型附加数据构成，映射和多重映射\r简单关联容器只有一个类型参数，二元关联容器有两个类型参数\r关联容器的键之间必须能使用\u0026quot;\\\u0026lt;\u0026quot;比大小，如果键是类类型，需重载运算符\rCpp规定\u0026quot;\\\u0026lt;\u0026quot;必须构成\u0026quot;严格弱序关系\u0026quot;\r非自反性 x\u0026lt;x必须返回false\r\u0026quot;\u0026lt;\u0026quot;传递性 x\u0026lt;y,y\u0026lt;z皆为true，则x\u0026lt;z必须返回true\r\u0026quot;==\u0026quot;传递性 x==y为!(x\u0026lt;y)\u0026amp;\u0026amp;!(y\u0026lt;x),若x==y,y==z皆为true，x==z必须为true\r关联容器基本功能\r#\r构造函数\r可以用迭代器的区间所表示的序列来构造\rS s(q1,q2) 使用[q1,q2)区间内的数据作为S的元素构造s\r单重关联容器 区间出现具有相同键的元素时，只有第一个元素加入\r多重关联容器 区间内所有元素被无条件加入s\r元素的插入\r无需通过迭代器指定插入位置\rs.insert(t) 将元素t插入s容器中\r单重关联容器 插入成功返回true，否则返回同键元素迭代器和false\r多重关联容器 返回已插入元素的迭代器\rs.insert(p1,t) 将t插入s中，p1是提示插入位置，函数总返回一个迭代器\r单重关联容器 插入成功返回元素迭代器，不成功返回同键迭代器\r多重关联容器 返回已插入元素迭代器\rs.insert(q1,q2) 按顺序对区间每个元素x分别执行s.insert(x)\r元素的删除\r两种通过迭代器指定删除元素方式有效，还允许通过键删除元素\rs.erase(p1) s.erase(p1,p2) s.erase(k)\r基于键的查找和计数\rs.find(k) 找到任意一个键为k的元素，返回该元素迭代器，否则返回s.end( )\rs.lower_bound(K) 得到第一个键值不小于k的元素的迭代器\rs.upper_bound(k) 得到第一个键值大于k的元素的迭代器\rs.equal_range(k) 得到\\[p1,p2),刚好包含所有键为k的元素\rs.count(k) 得到s容器中键为k的元素个数\r列表初始化\r一元关联容器直接提供元素列表，二元关联容器通过元素键值对\r4中关联容器的特性\r#\r集合\rSTL集合的元素个数必须有限\r映射\r类似字典，支持[ ]运算符\r可以通过s[ ]插入新元素、修改或者查询已有元素的附加数据\r多重集合\r多重映射\r不支持[ ]运算符\r无序容器\r#\r无序容器通过哈希函数和键类型的==运算符组织元素\r在键类型没有明显序关系或维护顺序代价高昂时，无序容器具有优势\r默认情况下，使用hash\\\u0026lt;key_type\\\u0026gt;生成哈希值，自定义类型需提供自己hash模板\r","date":"2025年12月6日","externalUrl":null,"permalink":"/note/cpp/10.2.%E5%AE%B9%E5%99%A8/","section":"笔记","summary":"","title":"10.2.容器","type":"note"},{"content":"函数对象\r#\r函数对象的概念\r#\r行为类似函数的对象，可以不需参数或带有若干参数\r功能是获取一个值或者改变操作的类型\r普通函数、函数指针、lambda表达式和重载运算符的类对象都可作为函数对象\r常用函数对象可分为五类\r产生器(Generator) 一元函数(Unary Function) 二元函数(Binary Function)\r一元谓词(Unary Predicate) 二元谓词(Binary Predicate)\r标准函数对象\r产生器、一元函数和二元函数\r一般具有0、1和2个传入参数的函数对象是产生器、一元函数和二元函数\rSTL标准库中二元函数对象\rplus\u0026lt;T\u0026gt; minus\u0026lt;T\u0026gt; multiplies\u0026lt;T\u0026gt;\rdivides\u0026lt;T\u0026gt; modulus\u0026lt;T\u0026gt; negate\u0026lt;T\u0026gt;\r一元谓词和二元谓词\r返回型为bool型，并具有一个或两个参数，称为一元谓词和二元谓词\requal_to\u0026lt;T\u0026gt; not_equal_to\u0026lt;T\u0026gt; greater\u0026lt;T\u0026gt; less\u0026lt;T\u0026gt; greater_equal\u0026lt;T\u0026gt;\rless_equal\u0026lt;T\u0026gt; logical_and\u0026lt;T\u0026gt; logical_or\u0026lt;T\u0026gt; logical_not\u0026lt;T\u0026gt;\rlambda表达式\r#\r类似未命名的内联函数，可定义在函数内部\r[捕获列表](参数列表)(-\u0026gt;返回类型)(可省去){函数体}\r捕获列表是所在函数中定义的局部变量列表，使用尾置返回\r函数对象参数绑定\r#\r参数绑定(bind)将一种函数对象转换为另一种符合要求的函数对象\rtemplate\\\u0026lt;class F,class\\...Args\\\u0026gt;\rbind(F \u0026amp;\u0026amp;f,Args\u0026amp;\u0026amp;\\...args);\rauto newFunc=bind(Func,arg_list);\r算法\r#\r算法本身就是一种函数模板\rSTL算法基础\r#\r不可变序列算法\r可变序列算法\r排序和搜索算法\r数值算法\r不可变序列算法(non-mutating algorithms)\r#\r指那些不直接修改所操作的容器内容的算法\r包括查找元素、相等检查、对序列元素计数的算法\r查找算法的目的\r查找元素位置并返回查找结果\r查找某个元素并返回元素或元素的值\r查找元素并返回是否在被查找的容器中\r可变序列算法(Mutating algorithms)\r#\r可以修改所操作的容器的元素\r算法的操作\r复制(copy) 生成(generate) 删除(remove) 替换(replace) 倒序(reverse)\r旋转(rotate) 交换(swap) 变换(transform) 分割(partition) 去重(unique)\r填充(fill) 洗牌(shuffle)\r排序和搜索算法\r#\r4个排序算法 sort partial_sort partial_sort_copy stable_sort\r4个二分查找 binary_search lower_bound uper_bound equal_range\r2个合并有序区间通用算法 merge inplace_merge\r4个最值算法 min max min_element max_element\r3个排列方式相关算法 lexicographical_compare next_permutation prev_permutation\r5个有序列集合操作算法 includes set_union set_intersection set_difference set_symmetric_difference\r4个堆创建和操作提供的算法 make_heap pop_heap push_heap sort_heap\n数值算法\r#\r调用此类算法需包含\u0026lt;numeric\u0026gt;头文件\r","date":"2025年12月6日","externalUrl":null,"permalink":"/note/cpp/10.3.%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%AE%97%E6%B3%95/","section":"笔记","summary":"","title":"10.3.函数对象和算法","type":"note"},{"content":"I/O流的概念及流类库结构\r#\r流是一种抽象，在数据生产者和数据消费者间建立联系，并管理数据流动\r文件对象有点特性，流对象也有，程序将流对象看作是文件对象的化身\r一般意义的读操作在流数据抽象中被称为提取，写操作被称为插入\r输出流\r#\r输出流对象是信息流动的目标，最重要三个是ostream，ofstream，ostringstream\rostream\r#\rcout是标准输出流\rcerr是标准错误输出流，没有缓冲，发送给它的内容立即被输出\rclog类似与cerr，但有缓冲，缓冲区满时被输出\r*标准输入流和输出流的区别在输出重定向时\r用命令行符\u0026gt;\u0026quot;filename\u0026quot;,cout输出内容会写到文件中，屏幕看不到\rcerr不受\u0026gt;影响，依旧直接显示在屏幕上，不写到文件里\rcerr可以通过2\u0026gt;\u0026quot;filename\u0026quot;进行重定向输出\rofstream\r#\rofstream类支持磁盘文件输出，需要只输出的磁盘文件可构造ofstream类对象\r打开文件之前或之后可以指定ofstream对象接受二进制或文本模式数据\r很多格式化选项和成员函数可用于ofstream对象，ios和ostream所有功能\r在构造函数中指定文件名，构造文件时文件自动打开\r或用open函数打开文件，或在文件标识符标识的打开文件上构造ofstream对象\r构造输出对象\r#\r如果使用预定义的cout、cerr、clog对象不需要构造输出流\r如果使用文件流将信息输出到文件，需要使用构造函数来建立流对象\r使用默认构造函数后调用open成员函数\rofstream myFile;\rmyFile.open(\u0026quot;filename\u0026quot;);\r在调用构造函数时指定文件名\rofstream myFile(\u0026quot;filename\u0026quot;);\r可以使用同一个流先后打开不同的文件(同一个时刻只有一个打开)\r使用插入运算符和操纵符\r#\r插入运算符\u0026quot;\u0026lt;\u0026lt;\u0026quot;是所有标准Cpp数据类型预先设计的\r插入运算符与预先定义的操纵符(manipulator)一起工作，用于控制输出格式\r很多操作符都定义在ios_base类中和iomanip头文件中\r输出宽度\r在流中放入setw操作符或调用width成员函数指定输出宽度\r默认填充符是空格，使用fill成员函数可以设置填充字符的值cout.fill()\rsetw和width都不截断数值，数值超指定宽度时显示全部值\rsetw和width仅影响紧随其后的域，一个域输出完后宽度恢复默认\r对齐方式\r输出流默认为右对齐文本\r通过使用带参数的setiosflags(定义在iomanip中)操纵符来设置对齐方式\rsetiosflags的影响是持久的，直到用resetiosflags重新恢复默认值为止\rseriosflags的参数是流的格式标识值，由下位掩码指定，可用\\|运算符组合\rios_base::skipws 在输入中跳过空白\rios_base::left 左对齐值，用填充字符填充右边\rios_base::right 右对齐值，用填充字符填充左边\rios_base::internal 规定宽度内，指定前缀符号后数值前插入指定填充字符\rios_base::unitbuf 在每次插入之后转储并清除缓冲区内容\r精度\rios_base::showpoint 对浮点数值显示小数点和尾部的0\rios_base::showpos 对非负数显示正号\rios_base::scientific 以科学格式显示浮点数值\rios_base::fixed 以顶点格式显示浮点数值(没有指数部分)\r可以使用setprecision操作符，以及ios_base::fixed和ios_base::scientific\r如果不指定fixed或scientific精度值表示有效数字位数\r如果设置了ios_base::fixed和ios_base::scientific，精度值表示小数点后位数\r进制\rios_base::showbase 插入前缀符号以表明整数的数制\rios_base::uppercase 对十六进制数值显示A-F，对于科学格式显示E\rios_base::dec 以是静止形式格式化数值\rios_base::oct 以八进制形式格式化数值\rios_base::hex 以十六进形式格式化数值\rdec、oct和hex操作符设置输入和输出的缺省进制\r文件输出流成员函数\r#\r输出流函数类型\r与操作符等价的成员函数\r执行非格式化写操作的成员函数\r其他修改流状态且不同于操纵符或插入运算符的成员函数\r*对于顺序的格式化输出，可以仅使用插入运算符和操纵符\r*对于随机访问二进制磁盘输出，用其他成员函数可选择性使用插入运算符\r输出流的open函数\r使用文件输出流，须在构造函数或open函数把流与特定磁盘文件关联\r打开一个与输出流关联的文件时，可以指定一个open_mode标志\rios_base::app 打开输出文件在文件尾添加数据\rios_base::ate 打开一个现存文件并查找到结尾\rios_base::in 打开输入文件，只读不写\rios_base::out 打开文件输出，此模式对ofstream对象隐含指定\rios_base::trunc 打开文件删除原有内容，若无非out指定则为隐含指定\rios_base::binary 以二进制模型打开一个文件(默认是文本模式)\r输出流的close函数\rclose成员函数关闭与一个文件输出流关联的磁盘文件\r文件使用完毕后必须将其关闭以完成所有磁盘输出\r如果需要在同一流对象上打开另外的文件，就需要使用close函数\r如果输出流对象析构前为调用close函数关闭，输出流析构函数自动关闭\rput函数\rput函数把一个字符写到输出流中，不受流的格式化参量的影响\rwrite函数\rwrite函数把内存的一块内容写到一个文件输出流中，长度参数指出字节数\rwrite函数遇到空字符时并不停止，能够写入完整的类结构\r函数带两个参数：char指针(需reinterpret_cast显式转换)，一个字节数\rseekp和tellp函数\r一个文件输出流保存一个内部指针指出下一次写数据的位置\rseekp成员函数设置这个指针，因此可以以随机方式相磁盘文件输出\rtellp成员函数返回该文件位置指针值\r错误处理函数\rbad 出现不可恢复的错误，返回一个非0值\rfail 出现不可恢复错误或预期条件返回非0值，零参调用clear清除错误标记\rgood 如果所有错误标记和文件结束标记都是清除的，返回一个非零值\reof 遇到文件结尾条件，则返回一个非0值\rclear 设置内部错误状态，如果用默认参数调用，则清除所有错误位\rrdstate 返回当前错误状态\r！运算符经过重载与fail函数执行相同的功能\rvoid*( )也经过重载，与！运算符相反\rvoid*( )不等价于good，因为不检测文件结尾\r二进制输出文件\r#\r不同操作系统的文本文件的行分隔符不尽相同\rWindows操作系统下的文本文件以一个换行符和回车符作为行分隔\r则以文本模式输出时，Windows系统下输出换行符会被自动扩充一个回车符\r若出现问题则需采用二进制模式输出，所写字符不转换\r二进制模式输出到文件，需在打开模式中设置ios_base::binary\r字符串输出流\r#\r输出流除了可以用于向屏幕或文件输出信息外，还可以用于生成字符串\r这样的流叫字符串流，ostringstream类就表示一个字符串输出流\rostringstream类有俩个构造函数\r第一个构造函数有一个形参，表示流的打开模式\r第二个构造函数接收两个形参，第一个给流赋初值，第二个表示打开模式\rostringstream类的功能\rostring与of(stream)同为ostream派生类，ostring具有of(stream)大部分功能\r专用于文件操作的open函数和close函数是ostringstream类不具备的\rostringstream类还有特有的函数str，返回string对象表示输出流生成的内容\rto_string函数模板可以把各种支持\u0026quot;\\\u0026lt;\\\u0026lt;\u0026quot;插入符的类型的对象转换为字符串\r输入流\r#\r输入流对象是数据流出的源头，最重要的输入类是istream、ifstream、istringstream\ristream\r#\ristream类适合顺序文本模式输入，基类ios的所有功能都包括在istream中\r预定义的istream对象cin用来完成从标准输入设备的输入\r标准输入设备也可以在命令行使用\u0026quot;\\\u0026lt;\u0026quot;中重定向，重定向后从文件读取数据\rifstream\r#\rifstream类支持磁盘文件输入\r如需仅用于输入的磁盘文件，可以构造ifstream对象，并指定二进制或文本模式\r如果在构造函数中指定文件名，在构造对象时文件自动打开\r否则调用默认构造函数后使用open函数打开文件\r很多格式化选项和成员函数都可以应用于ifstream对象\r构造输入流对象\r#\r如果使用文件流从文件中读取数据，必须构造一个输入流对象\r使用默认构造函数建立对象后调用open成员函数打开文件\rifstream myFile;\rmyFile.open(\u0026quot;filename\u0026quot;);\r在调用构造函数建立文件流对象时指定 文件名和模式\rifstream myFile(\u0026quot;filename\u0026quot;); or\rstring filename=\u0026quot;file.txt\u0026quot;;\rifstream myFile(filename);\r使用提取运算符\r#\r提取运算符\u0026quot;\u0026gt;\u0026gt;\u0026quot;对于所用标准Cpp数据类型都预先设计好\r提取运算符用于格式化文本输入，提取数据时以空白符为分割\r如果输入包含空白符的文本，可以使用非格式化输入成员函数getline\r输出流错误处理函数同样可以应用于输入流\r输入流操纵符\r#\r定义在ios_base类中和iomanip头文件中的操作符可以应用于输入流\r只要少数几个操作符对输入流对象具有实际影响，最重要的是dec、oct、hex\rhex可接受各种输入流格式，任何0\\~9,A\\~F,a\\~f和X外字符都引起数值变换终止\r输入流相关的函数\r#\r输入流的open函数\r如使用文件输入流，须在构造函数中或open函数关联流和特定磁盘文件\r当打开与输入流关联的文件时，通常要指定一个模式标志\rios_base::in 打开文件用于输入(默认)\rios_base::binary 以二进制模式打开文件\r输入流的close函数\r如果使用同一流对象打开另一个文件，首先使用close函数关闭当前文件\rget函数\r非格式化get函数的功能与提取运算符相仿，但读入数据时包括空白字符\rgetline函数\r允许输入流中读取多个字符，允许指定输入终止字符(默认换行字符)\r成员getline读完从读取内容删除终止字符，将内容存在字符数组不能扩容\r非成员函数getline将内容保存在string类型的对象中，更加方便\rgetline可以接受三个参数，输入流，保存string对象和终止字符(可选)\r非成员函数getline声明再string头文件中\rread函数\r从一个文件读字节到一个指定的存储器区域，有长度参数确定要读的字节数\r给出长度参数，遇到文件结束或文本模式中遇到文件结束标记字符时结束\rseekg和tellg函数\r文件输入流保留指向下一将读数据位置的内部指针，可以用seekg设置\rtellg成员函数返回当前文件读指针的位置，这个值是streampos类型\r字符串输入流\r#\r提供与字符串输出流相对应的功能\ristringstream两个构造函数，最常用构造函数接受两个参数\r两个参数分别表示要输入的string对象和流的打开模式(默认ios_base::in)\ristringstream有ifstream的大部分功能，只有open和close不具备\r输入输出流\r#\r一个iostream对象可以是数据的源或目的\rfstream和stringstream都是从iostream派生，继承了istream和ostream类功能\rfstream类支持磁盘文件输入和输出，一般有两个逻辑子流的单个流\rstringstream类支持面向字符串的输入和输出，可以用于对同一个字符串交替读写\r*宽字符、宽字符串与宽流\r#\r宽字符、宽字符串用于解决汉字占据两char字符时出现的问题\r宽字符与宽字符串\r#\r一般的宽字符数据占据两字节，类型名称时wchar_t\r一个宽字符文字仍需单引号包含，但在第一个单引号前需加L标识\rwstring表示宽字符串类型，除元素是wchar_t类型外与string完全相同\r宽字符串文字需双引号且第一个双引号前加L标识\r宽流\r#\rwstring无法用cout输出，cout基本单位是char类型字符\r一系列输入、输出和输入输出流前加 w可以得到对应流\r*对象的串行化\r#\r将对象写入文件的过程叫对象的串行化\r串行化的对象可以通过网络传给其他计算机或储存在数据库中\r","date":"2025年12月6日","externalUrl":null,"permalink":"/note/cpp/11.%E6%B5%81%E7%B1%BB%E5%BA%93%E4%B8%8E%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/","section":"笔记","summary":"","title":"11.流类库与输入输出","type":"note"},{"content":"","date":"2025年12月6日","externalUrl":null,"permalink":"/tags/cpp/","section":"Tags","summary":"","title":"Cpp","type":"tags"},{"content":"","date":"2025年12月6日","externalUrl":null,"permalink":"/note/cpp/","section":"笔记","summary":"","title":"Cpp程序设计","type":"note"},{"content":"","date":"2025年12月6日","externalUrl":null,"permalink":"/tags/stl/","section":"Tags","summary":"","title":"STL","type":"tags"},{"content":"","date":"2025年12月6日","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"2025年12月6日","externalUrl":null,"permalink":"/note/","section":"笔记","summary":"","title":"笔记","type":"note"},{"content":"","date":"2025年12月6日","externalUrl":null,"permalink":"/create/","section":"创作","summary":"","title":"创作","type":"create"},{"content":"","date":"2025年12月6日","externalUrl":null,"permalink":"/tags/%E7%AC%AC%E4%B8%89%E4%BA%BA%E7%A7%B0/","section":"Tags","summary":"","title":"第三人称","type":"tags"},{"content":"","date":"2025年12月6日","externalUrl":null,"permalink":"/tags/%E7%AC%AC%E4%B8%80%E4%BA%BA%E7%A7%B0/","section":"Tags","summary":"","title":"第一人称","type":"tags"},{"content":"","date":"2025年12月6日","externalUrl":null,"permalink":"/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8/","section":"Tags","summary":"","title":"迭代器","type":"tags"},{"content":"","date":"2025年12月6日","externalUrl":null,"permalink":"/tags/%E8%AE%BD%E5%96%BB/","section":"Tags","summary":"","title":"讽喻","type":"tags"},{"content":"","date":"2025年12月6日","externalUrl":null,"permalink":"/","section":"个人博客","summary":"","title":"个人博客","type":"page"},{"content":"","date":"2025年12月6日","externalUrl":null,"permalink":"/tags/%E5%87%BD%E6%95%B0/","section":"Tags","summary":"","title":"函数","type":"tags"},{"content":"","date":"2025年12月6日","externalUrl":null,"permalink":"/tags/%E7%A7%91%E5%B9%BB/","section":"Tags","summary":"","title":"科幻","type":"tags"},{"content":"","date":"2025年12月6日","externalUrl":null,"permalink":"/tags/%E5%8E%86%E5%8F%B2/","section":"Tags","summary":"","title":"历史","type":"tags"},{"content":"","date":"2025年12月6日","externalUrl":null,"permalink":"/tags/%E6%B5%81%E7%B1%BB/","section":"Tags","summary":"","title":"流类","type":"tags"},{"content":"","date":"2025年12月6日","externalUrl":null,"permalink":"/tags/%E8%BF%B7%E5%AE%AB%E5%BC%8F%E5%8F%99%E4%BA%8B/","section":"Tags","summary":"","title":"迷宫式叙事","type":"tags"},{"content":"","date":"2025年12月6日","externalUrl":null,"permalink":"/tags/%E5%AE%B9%E5%99%A8/","section":"Tags","summary":"","title":"容器","type":"tags"},{"content":"","date":"2025年12月6日","externalUrl":null,"permalink":"/tags/%E7%A5%9E%E8%AF%9D/","section":"Tags","summary":"","title":"神话","type":"tags"},{"content":"","date":"2025年12月6日","externalUrl":null,"permalink":"/tags/%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"算法","type":"tags"},{"content":"","date":"2025年12月6日","externalUrl":null,"permalink":"/tags/%E7%89%B9%E6%AE%8A%E8%A7%86%E8%A7%92/","section":"Tags","summary":"","title":"特殊视角","type":"tags"},{"content":"","date":"2025年12月6日","externalUrl":null,"permalink":"/create/novel/","section":"创作","summary":"","title":"小说","type":"create"},{"content":"","date":"2025年12月6日","externalUrl":null,"permalink":"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/","section":"Tags","summary":"","title":"字符串","type":"tags"},{"content":"","date":"2025年11月27日","externalUrl":null,"permalink":"/tags/adt/","section":"Tags","summary":"","title":"ADT","type":"tags"},{"content":"","date":"2025年11月27日","externalUrl":null,"permalink":"/tags/%E7%B1%BB/","section":"Tags","summary":"","title":"类","type":"tags"},{"content":"","date":"2025年11月27日","externalUrl":null,"permalink":"/tags/%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"模板","type":"tags"},{"content":"","date":"2025年11月24日","externalUrl":null,"permalink":"/tags/%E5%A4%9A%E6%80%81/","section":"Tags","summary":"","title":"多态","type":"tags"},{"content":"","date":"2025年11月24日","externalUrl":null,"permalink":"/tags/%E7%BB%A7%E6%89%BF/","section":"Tags","summary":"","title":"继承","type":"tags"},{"content":"","date":"2025年11月24日","externalUrl":null,"permalink":"/note/datastructandalgorithm/","section":"笔记","summary":"","title":"数据结构与算法","type":"note"},{"content":"","date":"2025年11月24日","externalUrl":null,"permalink":"/tags/%E6%95%B0%E7%BB%84/","section":"Tags","summary":"","title":"数组","type":"tags"},{"content":"","date":"2025年11月24日","externalUrl":null,"permalink":"/tags/%E5%8F%8B%E5%85%83/","section":"Tags","summary":"","title":"友元","type":"tags"},{"content":"","date":"2025年11月24日","externalUrl":null,"permalink":"/tags/%E6%8C%87%E9%92%88/","section":"Tags","summary":"","title":"指针","type":"tags"},{"content":"","date":"2025年11月24日","externalUrl":null,"permalink":"/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/","section":"Tags","summary":"","title":"作用域","type":"tags"},{"content":"\r👋 自我介绍\r#\r你好！欢迎来到这个网站。\n这个是我使用 Hugo 和 GitHub Pages 搭建的个人博客，用于记录个人学习和生活\n📚 博客内容\r#\r学习笔记：主要是数学学习和计算机科学学习 个人创作：偶尔也有个人创作，大多是短篇小说 🎓 教育背景\r#\r学校：[武汉大学] 专业：[人工智能] 年级：[2025级本科] 📬 与我联系\r#\r很高兴能与你交流！你可以通过以下方式找到我：\n邮箱：wrongtrojan0@gmail or 2405170138@qq.com\nGitHub：试试点击作者下方的Github图标😀\n感谢你的访问！我会持续更新内容。\n","date":"2025年11月23日","externalUrl":null,"permalink":"/about/","section":"个人博客","summary":"","title":"关于","type":"page"}]