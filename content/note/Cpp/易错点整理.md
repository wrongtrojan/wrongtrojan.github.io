+++
title = "易错点整理"
weight=17
date = 2025-12-18
draft = false
tags=["Cpp"]
+++
<!--more-->
### 关键字

- 语言本身预定义的,具有固定语义和用途的特殊标识符
<br>

- **不是关键字的标识符**
  1. 自定义标识符:自行命名的变量,函数,命名空间等
 
  2. 标准库相关的标识符:C++标准库中的类,函数,命名空间,宏等

      |类别|示例|
      |:---|:---|
      |命名空间|`std`|
      |容器/类型|`string` `vector` `map` `set`|
      |输入输出|`cout` `cin` `endl` `cerr`|
      |宏/类型别名|`NULL` `size_t` `ssize_t`|
      |算法/工具|`sort` `find` `make_pair`|
 
  3. 编译器扩展:各编译器的扩展语法不是标准C++关键字<br>(各种预编译指令如`include` `define`)
  4. 字面量,常量(true/false/nullptr除外)
<br>
- *override/final是**上下文关键字**
<br>

### 运算符

- `||`和`&&`有短路效应
<br>

- **运算符优先级**
  
   |运算符类型|具体运算符|
   |:---|:---|
   |基础/成员访问|`()` `[]` `.` `->` `::` `++`(后置) `--`(后置)|
   |单目运算|`!` `~` `++`(前置) `--`(后置) `+` `-` `&`(取地址) `*`(取值)<br> `sizeof` `typeid` `new/delete` 类型转换(如`stati_cast`)|
   |算术运算|`*` `/` `%` **>** `+` `-`|
   |位移运算|`<<`(左移) `>>`(右移)|
   |关系运算|`<` `<=` `>` `>=` **>** `==` `!=`|
   |按位运算|`&` **>** `^` **>** `\|`|
   |逻辑运算|`&&` **>** `\|\|`|
   |条件运算|`?:`|
   |赋值运算|`=` `(算术运算/位移运算/按位运算)=`|
   |逗号运算|`,`|
<br>

- **位移运算补零**
   |运算类型|操作数类型|补位规则|
   |:---|:---|:---|
   |左移`<<`|所有整数类型|一律补0|
   |右移`>>`|无符号整数|补零|
   |右移`>>`|有符号整数|补符号位|
<br>

### 函数参数
- 函数原型声明时可以省略形参名只保留参数类型
<br>
- 默认形参可以出现在函数声明和定义中
<br>

### 复制构造函数实现深层拷贝
```C++
template <typename T1,typename T2>
class Example{
   T1 data;
   T2 *ptr;
public:
   Example() : data(T1()), pr(nullptr) {}
   Example(const T1& d, const T2 & p_val) : data(d) {
        ptr = new T2(p_val); //分配内存并初始化
   }
   Example(const Example &E){
      data=E.data;
      if (E.ptr != nullptr) { //空指针判断，避免解引用空指针
            ptr = new T2(*E.ptr); //分配新内存，用源对象pr指向的内容初始化
      }else {
            ptr = nullptr;
         }
   }
   ~Example(){
      delete ptr; //释放pr指向的内存
      ptr=nullpr; //置空避免野指针
   }
};   
```
<br>

### 类成员的初始化
- 成员的初始化顺序由类中成员声明顺序决定
   ```C++
   class Example {
    int x; // 声明顺序1
    int y; // 声明顺序2
   public:
      Example(): y(1),x(y) { 
        //实际顺序:先初始化x(y,随机值),再初始化y(值1)
        cout<<x<<" "<<y<<endl; //输出:随机值 1
      }
   };
   ```
<br>

-  成员列表初始化在构造体赋值之前
   ```C++
   class Example {
    int a;       //普通成员
    const int b; //const成员(只能初始化,不能赋值)
    int& c;      //引用成员(只能初始化,不能赋值)
   public:
   Example(int x, int& ref) : a(x), b(x+1), c(ref) {
        a = x*2; //覆盖a的初始值(x→x*2)
   !    b = x+2; //错误!const成员已初始化,无法赋值
   !    c = ref+1; //错误!引用已绑定,无法赋值
      }
   };
   ```
<br>

### 前向引用声明

- 让编译器直到"实体存在",但不知道**大小**,**成员**,**实现**
<br>

- **对成员声明的使用限制**
   ```C++
   #pragma once
   class ExampleB;
   class ExampleC;
   class ExampleA{
      ExampleB *bptr1; //声明指针
      ExampleB &bptr2; //声明引用
   public:
      ExampleC FunC(ExampleC &C); //声明函数参数/返回值
   };
   ```
<br>
 
-  |**禁止做的操作**|
   |:---|
   |实例化该类型对象(`Example E;`编译器需知道大小)|
   |使用`sizeof(Example)`/`alignof(Example)`(编译器需知道大小)|
   |访问该类型成员(`E.<menber>`),编译器需知道成员|
   |继承该类型(`class Example1:public Example2{};`编译器需知道布局)|
   |调用该类型函数(编译器需知道函数实现)|
<br>

### 左值与右值

- 左值有持久的内存地址，右值是临时的无持久地址

- 函数表达式`func()`作为左右值

   |函数返回类型|`func()`类别|能否取地址|
   |:---|:---|:---|
   |左值引用(`T&`)|左值(lvalue)|✅|
   |右值引用(`T&&`)|亡值(xvalue,属于右值)|✅|
   |值类型(`T`)|纯右值(prvalue)|❌|
<br>

### static

- 类内static变量必须在外部定义
   ```C++
   class Example{
      static int val; //仅声明不定义
   }
   //必须在类外定义且不能用static修饰
   //注意:定义与访问是独立的规则
   int Example::val=10;
   ```
<br>

- 静态方法不能直接访问非静态成员<br>静态方法无`this`指针,无法直接访问非静态成员
   ```C++
   class Example{
      static int val1;
      int val2=5;
   public:
      static void func(){
      !  cout<<val1<<endl //合法
         cout<<val2<<endl //错误!不能直接访问非静态成员
      }
   }
   //必须在类外定义且不能用static修饰
   int Example::val1=10;
   ```
<br>

### const

- const与指针
   |写法|不可修改对象|
   |:---|:---|
   |`const int *ptr`<br>`int const *ptr`|不可修改指向的对象(`*p`)|
   |`int * const ptr`|不可修改ptr的指向(`ptr`)|
   |`const int* const p`|指向合指向对象均不可修改|
<br>

- const与引用
   1. `const`引用可以绑定任意对象,绑定后无法通过引用修改
   2. `const`引用支持隐式转换,非`const`引用不行
      ```C++
      double d=3.14;
      const int &ref1=d; //合法
      ! int &ref2=d; //错误!非const引用不能绑定临时对象
      ```
<br>

- const与类
  1. `const`成员变量只能在构造函数初始化列表中初始化
      ```C++
      class Example{
       const int val; //const成员变量
      public:
      ! Example() { 
           val = 10; //错误!此时val已初始化,无法修改
        }
      Example() : val(10) {} //仅初始化列表能初始化const成员
      };
      ```
  2. `const`成员函数const修饰在参数列表后<br>例如`void func() const{return}`
  3. `const`对象只能调用`const`成员函数,非`const`对象任意调用
<br>

- const与函数
  1. 参数中的`const`引用/指针限制函数修改实参
  2. 返回值中的`const`引用/指针限制调用方修改原对象
<br>

### 友元

- 在类型A中声明`friend class B`是A授权**允许B访问A的私有成员**
   ```C++
   class B; //前置声明
   class A{
      int valA=10;
      friend class B; //A授权B访问自己的私有成员
   public:
      void accessB(B& b){
      !  std::cout<<b.valB; //错误!A不是B的友元，无法访问B的私有成员 
      }
   };
   class B{   
    int valB=20;
   public:
      void accessA(A &a){
        std::cout <<a.valA; //合法:B是A的友元
      }
   };
   ```
<br>

- 友元关系不可继承不可传递
<br>

- 友元函数在类内声明但不是该类的成员函数<br>本质是授权**允许函数访问类的私有成员**
   ```C++
   class Example{
   private:
      int val = 10;
      friend void friendfunc(Example &obj); //声明友元函数全局函数
   public:
      void func() {
      !  this->friendfunc(*this);// 错误!friendfunc不是成员函数，不能用this调用 
      }
   };
   void friendfunc(Example &obj) {
      std::cout<<obj.val;
   }
   ```
<br>

- 友元函数仅针对特定重载版本,不覆盖所有重载