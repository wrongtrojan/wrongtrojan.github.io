+++
title = "10.2.容器"
weight=12
date = 2025-12-06
tags =["Cpp","STL","容器"]
draft = false
+++
<!--more-->

## 容器的基本功能与分类

>### 容器的基本功能
>
>       S s1 默认构造函数，构造没有任何元素的空容器
>
>       s1 op s2 op是关系运算符，对两个容器之间的元素按字典序进行比较
>
>       s1.begin( ) 返回指向s1第一个元素的迭代器
>
>       s1.end( ) 返回指向s1最后一个元素的下一个位置迭代器
>
>       s1.clear( ) 将容器s1的内容清空
>
>       s1.empty( ) 返回一个布尔值，表示s1容器是否为空
>
>       s1.size( ) 返回s1的元素个数
>
>       s1.swap(s2) 将s1容器和s2容器的内容交换

>### 逆向迭代器
>
>       STL提供的标准容器至少是可逆容器，STL为每个可逆容器提供了逆向迭代器
>
>       s1.rbegin( ) 得到指向容器的最后一个元素的逆向迭代器
>
>       s1.rend( ) 得到指向容器的第一个元素的前一个位置的逆向迭代器
>
>       逆向迭代器类型名表示方法
>
>           S::reverse_iterator 与S相关的普通迭代器类型
>
>           S::const_reverse_iterator 与S相关的常迭代器类型，只能读取，不能改写
>
>       逆向迭代器实际上是普通迭代器的适配器
>
>       迭代器和逆迭代器转换
>
>           迭代器和逆迭代器之间可以相互转换
>
>           若p1是S::iterator类型的迭代器，S::reverse_iterator(p1)得到对应逆迭代器

## 顺序容器

>### 顺序容器的基本功能
>
>       构造函数
>
>           顺序容器可以使用给定的元素和已有迭代器区间所表示的序列构造
>
>           S s(n,t); 构造一个由n个t元素构成的容器实例s
>
>           S s(n); 构造一个有n个元素的容器实例s，每个元素都是T( )
>
>           S s(q1,q2) 使用将[q1,q2)区间内的数据作为S的元素构造s
>
>       赋值函数
>
>           使用成员函数assign将指定元素赋给顺序容器，原先元素会被清除
>
>           s.assign(n,t) s.assign(n) s.assign(q1,q2)
>
>       元素的插入
>
>           向顺序容器一次插入一或多个指定元素，也可以将迭代器区间表示序列插入
>
>           插入时需要通过指向当前容器元素的迭代器来指示插入位置
>
>           s.insert(p1,t) 在p1和p1-1位置间插入新元素，返回指向新元素迭代器
>
>           s.insert(p1,n,t) 在p1和p1-1位置间插入n个元素t，没有返回值
>
>           s.insert(p1,q1,q2) 将[q1,q2)区间元素顺序插入到p1和p1-1之间
>
>           s.emplace(p1,args) 以args构造t插入p1和p1-1间，返回指向新元素迭代器
>
>       元素的删除
>
>           从容器中删除指定元素或清空容器，删除指定元素需指向元素的迭代器指示
>
>           s.erase(p1) 删除s容器中p1指向的元素，返回被删除的下一个元素迭代器
>
>           s.erase(p1,p2) 删除[p1,p2)内的元素，返回最后被删元素下一个元素迭代器
>
>       改变容器的大小
>
>           s.resize(n) 将容器大小变为n，原有元素多余则删除，不够则T( )填充
>
>       首尾元素直接访问
>
>           s.front( ) 获得容器首元素的引用
>
>           sback( ) 获得容器尾元素的引用
>
>       在容器尾部插入、删除元素
>
>           s.push_back(t) 向容器尾部插入元素t
>
>           s.emplace_back(args) 将参数args传递给T构造再向尾部插入元素
>
>           s.pop_back( ) 将容器尾部的元素删除
>
>       在容器头部插入、删除元素
>
>           s.push_front(t) s.emplace_front(args) s.pop_front( )
>
>       容器的列表初始化
>
>           s<type> name={, , , };

> ### 5种顺序容器的特性
>
>       向量
>
>           核心特性
>
>               支持高效随机访问，尾部插入/删除效率高
>
>               中部或头部插入/删除需移动元素，效率低
>
>               动态扩容，空间不足时分配更大内存，扩容是会预留额外空间
>
>           特有函数
>
>               capacity( )(获取容器) reserve(n)(预留分配至少n的容量)
>
>               shrink_to_fit(回收未使用空间)
>
>           迭代器/指针失效
>
>               扩容时，所有迭代器、指针、引用失效
>
>               未扩容的插入/删除，仅插入/删除位置后的迭代器、指针、引用失效
>
>       队列
>
>           核心特性
>
>               支持两端高效插入/删除,无需移动元素
>
>               随机访问效率低于vector
>
>               中间插入/删除需移动元素，效率低
>
>           迭代器/指针失效
>
>               两端操作，所有迭代器失效，但指针、引用不失效
>
>               中间操作，所有迭代器、指针、引用失效
>
>       列表
>
>           核心特性
>
>               不支持随机访问
>
>               任意位置插入/删除效率高(仅需修改指针，无需移动元素)
>
>               支持拼接操作(splice)，高效转移另一个list元素
>
>           特有函数
>
>               splice( )(拼接) remove( )(删除指定元素)
>
>           迭代器/指针失效
>
>               仅被删除元素的迭代器、指针、引用失效
>
>       单向链表
>
>           核心特性
>
>               仅支持前向遍历
>
>               插入/删除操作是insert_after/erase_after
>
>               无size( )函数
>
>       数组
>
>           核心特性
>
>               内置数组的封装，大小固定
>
>               支持随机访问，更安全，但不能动态扩容
>
>           顺序容器的选择
>
>               大量随机访问+尾部操作 vector
>
>               两端操作+少量随机访问 deque
>
>               中间插入/删除频繁 list/forward_list
>
>               固定大小数组 array

> ### 顺序容器的插入迭代器
>
>       在顺序容器(array外)插入元素，还可以通过插入迭代器
>
>           template<class Container>class front_insert_iterator;
>
>       template<class Container>class back_insert_iterator;
>
>       template<class Container>class insert_iterator;

> ### 顺序容器的适配器
>
>       对顺序容器进行封装，按照指定顺组访问和删除容器种的元素

## 关联容器

>### 关联容器的分类
>
>       容器中元素的顺序按照键的取值升序排列
>
>       关联容器的最大优势在可以高效根据键查找容器的一个元素
>
>       按照是否允许重复键值
>
>           单重关联容器 键值唯一不允许重复，集合和映射
>
>           多重关联容器 键值允许重复出现，多重集合和多重映射
>
>       按照键和元素关系
>
>           简单关联容器 元素本身作为键，集合和多重集合
>
>           二元关联容器 元素由键和某种类型附加数据构成，映射和多重映射
>
>       简单关联容器只有一个类型参数，二元关联容器有两个类型参数
>
>       关联容器的键之间必须能使用"\<"比大小，如果键是类类型，需重载运算符
>
>           Cpp规定"\<"必须构成"严格弱序关系"
>
>               非自反性 x<x必须返回false
>
>               "<"传递性 x<y,y<z皆为true，则x<z必须返回true
>
>               "=="传递性 x==y为!(x<y)&&!(y<x),若x==y,y==z皆为true，x==z必须为true

>### 关联容器基本功能
>
>       构造函数
>
>           可以用迭代器的区间所表示的序列来构造
>
>           S s(q1,q2) 使用[q1,q2)区间内的数据作为S的元素构造s
>
>           单重关联容器 区间出现具有相同键的元素时，只有第一个元素加入
>
>           多重关联容器 区间内所有元素被无条件加入s
>
>       元素的插入
>
>           无需通过迭代器指定插入位置
>
>           s.insert(t) 将元素t插入s容器中
>
>               单重关联容器 插入成功返回true，否则返回同键元素迭代器和false
>
>               多重关联容器 返回已插入元素的迭代器
>
>           s.insert(p1,t) 将t插入s中，p1是提示插入位置，函数总返回一个迭代器
>
>               单重关联容器 插入成功返回元素迭代器，不成功返回同键迭代器
>
>               多重关联容器 返回已插入元素迭代器
>
>           s.insert(q1,q2) 按顺序对区间每个元素x分别执行s.insert(x)
>
>       元素的删除
>
>           两种通过迭代器指定删除元素方式有效，还允许通过键删除元素
>
>           s.erase(p1) s.erase(p1,p2) s.erase(k)
>
>       基于键的查找和计数
>
>           s.find(k) 找到任意一个键为k的元素，返回该元素迭代器，否则返回s.end( )
>
>           s.lower_bound(K) 得到第一个键值不小于k的元素的迭代器
>
>           s.upper_bound(k) 得到第一个键值大于k的元素的迭代器
>
>           s.equal_range(k) 得到\[p1,p2),刚好包含所有键为k的元素
>
>           s.count(k) 得到s容器中键为k的元素个数
>
>       列表初始化
>
>           一元关联容器直接提供元素列表，二元关联容器通过元素键值对

> ### 4中关联容器的特性
>
>       集合
>
>           STL集合的元素个数必须有限
>
>       映射
>
>           类似字典，支持[ ]运算符
>
>           可以通过s[ ]插入新元素、修改或者查询已有元素的附加数据
>
>       多重集合
>
>       多重映射
>
>           不支持[ ]运算符

## 无序容器

>       无序容器通过哈希函数和键类型的==运算符组织元素
>
>       在键类型没有明显序关系或维护顺序代价高昂时，无序容器具有优势
>
>       默认情况下，使用hash\<key_type\>生成哈希值，自定义类型需提供自己hash模板
