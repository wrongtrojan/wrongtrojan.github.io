+++
title = "广度优先算法"
weight= 10
date = 2025-12-26
draft = false
tags=["BFS"]
+++
<!--more-->
### 适用问题

1. 无权图/等权图的最短路径
> BFS第一次到达目标节点的路径即最短路径
   - 迷宫最短路径
   - 词梯问题

2. 层级遍历问题
> BFS天然适配按[层级]处理节点的场景
   - 二叉树的层序遍历
   - 图的层级划分

3. 连通性问题
> 判断图的联通性,统计联通分量数量
   - 岛屿数量问题
   - 无向图的连通分量统计 

4. 多源BFS问题
> 多个起始节点同时开始扩散,所有节点被覆盖的最短时间或步骤
   - 树木燃烧问题
   - 多源点的最短距离
<br>

### BFS解题思路

1. 抽象问题为图模型
   - **节点**:问题的基本单元
   - **边** :节点之间的合法转移关系
   - **起始节点&目标节点**:明确搜索的起点和终点

2. 核心数据结构
   - **队列**:用于存储待处理节点, 保证FIFO逐层遍历
   - **访问标记**:用于记录节点是否被访问,避免重复访问
    ```C++
    #include <vector>
    struct Node{
        int x,y;
        int step;
    }
    vector<vector<bool>> visited(n,vector<bool>(m,false));
    ```

3. 初始化队列与访问标记
   - 将所有起始节点加入队列
   - 将起始节点标记为**已访问**

4. 核心循环-逐层遍历
    ```C++
    int dirs[4][2]={{1,0},{-1,0},{0,1},{0,-1}};
    while(!queue.empty()){
        T temp =queue.front();//取出队列首项
        queue.pop();//队列首项出队
        //若temp是目标节点可直接返回结果
        //此处省略
        int nodex=temp.x;
        int nodey=temp.y;
        //遍历与temp节点的相邻节点
        for(auto dir:dirs){
            nodex=temp.x+dir[0];
            nodey=temp.y+dir[1];
            //确保相邻节点是合法节点
            if(nodex>=0&&nodex<n&&nodey>=0&&nodey<m&&!visited[nodex][nodey]){
                queue.push({nodex,nodey,temp.step+1});
                visited[nodex][nodey]=true;
            }
        }
    }
    ```

5. 处理结果或边界情况
   - 在循环中找到目标节点,返回对应的步数/路径
   - 若循环结束未找到目标->目标不可达