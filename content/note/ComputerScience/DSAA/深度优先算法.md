+++
title = "动态规划"
weight= 11
date = 2025-12-26
draft = false
tags=["DFS"]
+++
<!--more-->
### 适合问题

1. 全排列/组合/子集问题(穷举)
> DFS[回溯]特性可以高效遍历所有可能性,且能灵活剪枝

2. 路径搜索问题
> 找出从起点到终点的**所有路径**,或判断是否存在满足条件的路径
    - 二叉树的所有路径
    - 矩阵中的路径

3. 连通性/遍历问题(比BFS更省时间)
> DFS的递归实现更加简洁.且空间复杂度更低

4. 回溯类问题([试错-回退])
> 问题的解需要通过[逐步尝试->验证->失败回退]方式找到
    - 八皇后问题
    - 数独求解
    - 括号生成

5. 拓扑排序(DAG)
> 对DAG节点排序,使得所有有向边从前面节点指向后面的节点
    - 任务调度

### DFS解题思路

1. 抽象问题为[状态空间]模型
    - **状态**:当前的选择/位置/进度
    - **状态转移**:从当前状态合法转移到下一个状态
    - **终止条件**:达到目标状态或无法继续转移

2. 选择实现方式(递归/非递归)
|实现方式|优点|缺点|
|:---|:---|:---|
|递归|代码简洁,逻辑直观|递归深度过大会栈溢出|
|非递归|可控性强,无栈溢出风险|代码繁琐|

**递归实现**
3. 设计递归函数
   - 递归函数的参数
     1. 当前状态(如坐标`x,y`,已选路径`path`)
     2. 访问标记(如`visited`数组)
     3. 结果收集容器(如`result`)
     4. 剪枝条件相关参数  
   - 逻辑框架
     1. 终止条件判断
     2. 遍历所有可能的下一步转移
        剪枝->标记->递归->回溯

**非递归实现**
3. 替代递归函数设计
   - 定义栈的元素结构
     1. 基础遍历场景
     2. 回溯场景  
   - 初始化栈
   - 核心循环
     1. 首次弹出[**递**] 
        - 标记为[已处理]并重新入栈
        - 收集当前状态
        - 找到所有[下一步待处理状态]压入栈
     2. 再次弹出[**归**]
        - 执行[回溯操作]
        - 判断是否满足终止条件
   - 终止条件判断

4. 剪枝优化
> 提前排除无效路径,避免不必要的递归
   - **可行性剪枝**
   - **重复性剪枝**
   - **合法性剪枝**  