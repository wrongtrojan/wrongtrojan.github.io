+++
title = "动态规划"
weight= 9
date = 2025-12-25
draft = false
tags=["DP"]
+++
<!--more-->

### 核心特征

1. 最优子结构
    - 问题的**全局最优解**可以由若干子问题的**局部最优解**组合得到

2. 重叠子问题
    - 解决原问题时会反复遇到相同的子问题,用"缓存"储存子问题的解避免重复计算

3. 无后效性
    - 子问题的解只依赖**过去的状态**不依赖于**未来的状态**
<br>

### 使用DP解题的思路

1. 问题分析->验证适用性+转换问题
   - 判断是否满足DP的核心特征
   - 若问题是求解最优且能拆分子问题
   - 对问题做转换,降低状态设计难度

2. 状态定义->维度+关键约束
   - 锚定最后一步(解决相邻关系/递推关系)
   - 状态维度=问题的可变约束数
   - 状态必须满足无后效性

3. 边界初始化->确定最基础子问题的解
   - 基础的子问题无法再拆分,解可以直接写出

4. 状态转移->当前状态=子问题最优解+一步决策
    - 明确当前状态dp[i][j]依赖哪些子状态
    - 明确子状态到当前状态的一步决策
    - 得到当前状态的最优解

5. 结果提取->DP数组中筛查覆盖目标的状态
    - DP状态是**子问题的解**,需要从状态中筛出**原问题的解**
<br>

### 常见DP问题类型
|问题类型|核心特征|状态定义技巧|转移核心|
|:---|:---|:---|:---|
|组合优化|最值,有约束|锚定最后一步+约束维度|子状态+决策|
|计数问题|求路径数|锚定最后一步|子状态|
|背包问题|选物品,容量/价值约束|物品数+容量维度|选/不选当前物品|
|区间DP|子问题是区间[l,r]|锚定区间长度/端点|枚举区间分割点|

<br>

### 代码实现P1103
```C++

#include <iostream>
#include <vector>
#include <cmath>
#include <algorithm>
#include <climits>
using namespace std;

struct Book {
    int height, width;
    bool operator<(const Book& b) const {
        return height < b.height;
    }
};

int main() {
    int n, k;
    cin >> n >> k;
    int m = n - k;  // 要保留的书的数量
    vector<Book> books(n);
    for (int i = 0; i < n; i++) {
        cin >> books[i].height >> books[i].width;
    }
    // 按高度排序
    sort(books.begin(), books.end());

    // 提取排序后的宽度数组
    vector<int> width(n);
    for (int i = 0; i < n; i++) {
        width[i] = books[i].width;
    }

    // DP数组：dp[i][j] = 前i本选j本保留，且第i本保留的最小不整齐度
    vector<vector<int>> dp(n, vector<int>(m+1, INT_MAX));
    
    // 初始化：选1本时，不整齐度为0
    for (int i = 0; i < n; i++) {
        dp[i][1] = 0;
    }

    // 状态转移
    for (int j = 2; j <= m; j++) {  // 选j本
        for (int i = j-1; i < n; i++) {  // 第i本作为最后一本（至少选j本，i≥j-1）
            for (int k = j-2; k < i; k++) {  // 前j-1本的最后一本是k
                if (dp[k][j-1] != INT_MAX) {
                    dp[i][j] = min(dp[i][j], dp[k][j-1] + abs(width[i] - width[k]));
                }
            }
        }
    }

    // 找所有选m本的最小不整齐度
    int ans = INT_MAX;
    for (int i = m-1; i < n; i++) {
        ans = min(ans, dp[i][m]);
    }

    cout << ans << endl;
    return 0;
}

```