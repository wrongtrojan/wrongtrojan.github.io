+++
title = "易错点整理"
weight=17
date = 2025-12-18
draft = false
tags=["Cpp"]
+++
<!--more-->
### 程序编写
- 程序编写步骤
  1. **编辑**：使用编辑器编写C++源码，生成`.cpp`源文件
  2. **编译**：编译器将源文件转换为机器语言`.obj`目标文件,同时检查语法错误
  3. **链接**:链接器将目标文件与系统库\其他模块结合,生成`.exe`可执行文件
  4. **调试**:运行可执行文件,检查并修复错误
<br>

- C++程序的基本单位/模块是函数
<br>

### 关键字

- 语言本身预定义的,具有固定语义和用途的特殊标识符
<br>

- **不是关键字的标识符**
  1. 自定义标识符:自行命名的变量,函数,命名空间等
 
  2. 标准库相关的标识符:C++标准库中的类,函数,命名空间,宏等

      |类别|示例|
      |:---|:---|
      |命名空间|`std`|
      |容器/类型|`string` `vector` `map` `set`|
      |输入输出|`cout` `cin` `endl` `cerr`|
      |宏/类型别名|`NULL` `size_t` `ssize_t`|
      |算法/工具|`sort` `find` `make_pair`|
 
  3. 编译器扩展:各编译器的扩展语法不是标准C++关键字<br>(各种预编译指令如`include` `define`)
  4. 字面量,常量(true/false/nullptr除外)
<br>
- *override/final是**上下文关键字**
<br>

### 运算符

- `||`和`&&`有短路效应
<br>

- **运算符优先级**
  
   |运算符类型|具体运算符|
   |:---|:---|
   |基础/成员访问|`()` `[]` `.` `->` `::` `++`(后置) `--`(后置)|
   |单目运算|`!` `~` `++`(前置) `--`(后置) `+` `-` `&`(取地址) `*`(取值)<br> `sizeof` `typeid` `new/delete` 类型转换(如`stati_cast`)|
   |算术运算|`*` `/` `%` **>** `+` `-`|
   |位移运算|`<<`(左移) `>>`(右移)|
   |关系运算|`<` `<=` `>` `>=` **>** `==` `!=`|
   |按位运算|`&` **>** `^` **>** `\|`|
   |逻辑运算|`&&` **>** `\|\|`|
   |条件运算|`?:`|
   |赋值运算|`=` `(算术运算/位移运算/按位运算)=`|
   |逗号运算|`,`|
<br>

- **位移运算补零**
   |运算类型|操作数类型|补位规则|
   |:---|:---|:---|
   |左移`<<`|所有整数类型|一律补0|
   |右移`>>`|无符号整数|补零|
   |右移`>>`|有符号整数|补符号位|
<br>

- **逗号运算符**规则:从左往右计算表达式,返回最后一个的值
   ```C++
   #include <iostream>
   using namespace std;
   void Func(int,int){return}
   int main(){
      int a=5,b=10;
      cout<<(a,b)<<endl; //输出为b,即10
      func((1,2),(3,4,5)); //调用func传入2和5两个参数
      return 0;
   }
   ```
<br>

### 函数参数
- 函数原型声明时可以省略形参名只保留参数类型
<br>
- 默认形参可以出现在函数声明和定义中
<br>

### 复制构造函数实现深层拷贝
```C++
template <typename T1,typename T2>
class Example{
   T1 data;
   T2 *ptr;
public:
   Example() : data(T1()), pr(nullptr) {}
   Example(const T1& d, const T2 & p_val) : data(d) {
        ptr = new T2(p_val); //分配内存并初始化
   }
   Example(const Example &E){
      data=E.data;
      if (E.ptr != nullptr) { //空指针判断，避免解引用空指针
            ptr = new T2(*E.ptr); //分配新内存，用源对象pr指向的内容初始化
      }else {
            ptr = nullptr;
         }
   }
   ~Example(){
      delete ptr; //释放pr指向的内存
      ptr=nullpr; //置空避免野指针
   }
};   
```
<br>

### 类成员的初始化
- 成员的初始化顺序由类中成员声明顺序决定
   ```C++
   class Example {
    int x; // 声明顺序1
    int y; // 声明顺序2
   public:
      Example(): y(1),x(y) { 
        //实际顺序:先初始化x(y,随机值),再初始化y(值1)
        cout<<x<<" "<<y<<endl; //输出:随机值 1
      }
   };
   ```
<br>

-  成员列表初始化在构造体赋值之前
   ```C++
   class Example {
    int a;       //普通成员
    const int b; //const成员(只能初始化,不能赋值)
    int& c;      //引用成员(只能初始化,不能赋值)
   public:
   Example(int x, int& ref) : a(x), b(x+1), c(ref) {
        a = x*2; //覆盖a的初始值(x→x*2)
   !    b = x+2; //错误!const成员已初始化,无法赋值
   !    c = ref+1; //错误!引用已绑定,无法赋值
      }
   };
   ```
<br>

### 前向引用声明

- 让编译器知到"实体存在",但不知道**大小**,**成员**,**实现**
<br>

- **对成员声明的使用限制**
   ```C++
   #pragma once
   class ExampleB;
   class ExampleC;
   class ExampleA{
      ExampleB *bptr1; //声明指针
      ExampleB &bptr2; //声明引用
   public:
      ExampleC FunC(ExampleC &C); //声明函数参数/返回值
   };
   ```
<br>
 
-  |**禁止做的操作**|
   |:---|
   |实例化该类型对象(`Example E;`编译器需知道大小)|
   |使用`sizeof(Example)`/`alignof(Example)`(编译器需知道大小)|
   |访问该类型成员(`E.<menber>`),编译器需知道成员|
   |继承该类型(`class Example1:public Example2{};`编译器需知道布局)|
   |调用该类型函数(编译器需知道函数实现)|
<br>

### 左值与右值

- 左值有持久的内存地址，右值是临时的无持久地址

- 函数表达式`func()`作为左右值

   |函数返回类型|`func()`类别|能否取地址|
   |:---|:---|:---|
   |左值引用(`T&`)|左值(lvalue)|✅|
   |右值引用(`T&&`)|亡值(xvalue,属于右值)|✅|
   |值类型(`T`)|纯右值(prvalue)|❌|
<br>

### static

- 类内static变量必须在外部定义
   ```C++
   class Example{
      static int val; //仅声明不定义
   }
   //必须在类外定义且不能用static修饰
   //注意:定义与访问是独立的规则
   int Example::val=10;
   ```
<br>

- 静态方法不能直接访问非静态成员<br>静态方法无`this`指针,无法直接访问非静态成员
   ```C++
   class Example{
      static int val1;
      int val2=5;
   public:
      static void func(){
      !  cout<<val1<<endl //合法
         cout<<val2<<endl //错误!不能直接访问非静态成员
      }
   }
   //必须在类外定义且不能用static修饰
   int Example::val1=10;
   ```
<br>

### const

- const与指针
   |写法|不可修改对象|
   |:---|:---|
   |`const int *ptr`<br>`int const *ptr`|不可修改指向的对象(`*p`)|
   |`int * const ptr`|不可修改ptr的指向(`ptr`)|
   |`const int* const p`|指向合指向对象均不可修改|
<br>

- const与引用
   1. `const`引用可以绑定任意对象,绑定后无法通过引用修改
   2. `const`引用支持隐式转换,非`const`引用不行
      ```C++
      double d=3.14;
      const int &ref1=d; //合法
      ! int &ref2=d; //错误!非const引用不能绑定临时对象
      ```
<br>

- const与类
  1. `const`成员变量只能在构造函数初始化列表中初始化
      ```C++
      class Example{
       const int val; //const成员变量
      public:
      ! Example() { 
           val = 10; //错误!此时val已初始化,无法修改
        }
      Example() : val(10) {} //仅初始化列表能初始化const成员
      };
      ```
  2. `const`成员函数const修饰在参数列表后<br>例如`void func() const{return}`
  3. `const`对象只能调用`const`成员函数,非`const`对象任意调用
<br>

- const与函数
  1. 参数中的`const`引用/指针限制函数修改实参
  2. 返回值中的`const`引用/指针限制调用方修改原对象
<br>

### 友元

- 在类型A中声明`friend class B`是A授权**允许B访问A的私有成员**
   ```C++
   class B; //前置声明
   class A{
      int valA=10;
      friend class B; //A授权B访问自己的私有成员
   public:
      void accessB(B& b){
      !  std::cout<<b.valB; //错误!A不是B的友元，无法访问B的私有成员 
      }
   };
   class B{   
    int valB=20;
   public:
      void accessA(A &a){
        std::cout <<a.valA; //合法:B是A的友元
      }
   };
   ```
<br>

- 友元关系不可继承不可传递
<br>

- 友元函数在类内声明但不是该类的成员函数<br>本质是授权**允许函数访问类的私有成员**
   ```C++
   class Example{
   private:
      int val = 10;
      friend void friendfunc(Example &obj); //声明友元函数全局函数
   public:
      void func() {
      !  this->friendfunc(*this);// 错误!friendfunc不是成员函数，不能用this调用 
      }
   };
   void friendfunc(Example &obj) {
      std::cout<<obj.val;
   }
   ```
<br>

- 友元函数仅针对特定重载版本,不覆盖所有重载
<br>

### 数组初始化

- `int arr[N]={n}`则第一个元素被初始化为n,其余元素初始化为0
<br>

- 多维数组初始化,第一维可由初始化列表推断,其他维必须显式指定
   ```c++
   //以二维数组为例
   ! int a[5][]; //错误:第二维必须显式指定大小
   ! int a[][5]; //错误:第一维没有提供初始化列表
   int a[][3]={{1,3,5},{2}}; //合法
   ```
<br>

- 数组命本质是常量指针,不可更改本身的值
   ```C++
   int arr[10]={0};
   *(arr+1)=1; //合法,做指针运算但没改变arr本身值
   ! *++arr=1; //错误!前置++会修改arr本身的值
   ```
<br>

### 指针

- **悬挂指针:**`delete`指针指向内存后未将指针置为`nullptr`
<br>

- **野指针:** 指针定义时没有初始化,随机指向内存中某个位置
<br>

- `int **ptr`与`int arr[N][N]`
   ```C++
   /*右侧返回一个指向[指针数组的首地址]的指针(指针的地址),
   由二级指针接收*/
   int **ptr1=new (int*)[10];

   /*右侧返回一个指向[含20个元素的一维数组]的指针
   由数组指针来接收*/ 
   int (*ptr2)[20]=new int[10][20]
   ```
<br>

- **`void*`指针**不可以直接赋给(隐式转换)非`void`指针
   ```C++
   void *void_ptr=new int(10);
   ! int *int_ptr=void_tpr; //错误!
   ```
<br>

- **`char*`指针**
   1. `char*`指针可以指向字符串字面量,其他类型不可以指向字面量
   2. `cout`默认输出`char*`指针指向的字符串内容,若要输出地址值需显示转换成`void*`指针
<br>  

- **指针运算的单位:** 指针运算以指向类型的大小为单位
<br>

- 函数不可返回局部变量指针,若有需求使用`new`向堆区申请
<br>

### 字符串

- 字符数组(C风格)
   1. 常见操作函数
      |函数|功能|
      |:---|:---|
      |`strlen`|字符串长度(不含`\0`)|
      |`strcpy`|字符串拷贝|
      |`strcat`|字符串拼接|
      |`strcmp`|字符串比较|
      |`strchr`|查找字符首次出现位置|
      |`strstr`|查找子串首次出现位置|

   2. 给字符数组赋初值时末位`\0`需占位
      ```C++
      ! char s[3]="abc" //错误,末位'\0'占位需4个连续地址
      char s[4]="abc" //合法
      ```
<br>


- **string类**
  1. 不可用字符串字面量拼接
     ```C++
     ! string s="hello"+"world"; //错误!字面量是常指针,不允许指针相加
     string s=string("hello")+"world"; //合法
     ```
  <br>

  1. 字符串长度计算中转义字符(如`\n`)只占1个字符位,末位`\0`不计入计算
  <br>

### 类的继承与多态

- 继承方式
   |基类成员属性|公有继承|保护继承|私有继承|
   |:---|:---|:---|:---|
   |公有|公有|保护|私有|
   |保护|保护|保护|私有|
   |私有|不可见|不可见|不可见|
<br>

- 虚函数<br>构造函数不能是虚函数,析构函数一般是虚函数
<br>

- 虚继承的语法格式
   ```C++
   class Derived : virtual public Base{};
   //等价于
   class Derived : public virtual Base{};
   ```
<br>

- 纯虚函数与抽象类
   1. 语法形式如 `virtual void func()=0`
   2. 只实现部分纯虚函数的派生类依旧是抽象类
   3. 纯虚析构函数必须在类外提供函数体(定义),否则链接报错
      ```C++
      class Base{
      public:
         virtual ~Base()=0 //声明纯虚析构函数
      }
      Base::~Base(){
         //所有子类共有的清理工作
      };
      class Derived: public Base{
      public:
         ~Derived(){
            //执行派生类的析构函数体,执行结束后会调用~Base()
         }
      }
      ```
<br>

- 在派生类中写基类同名函数
   |函数类型|绑定方式|行为|使用基类指针指派生类对象|
   |:---|:---|:---|:---|
   |普通函数|静态绑定|**隐藏**|调用函数时依旧使用**基类**版本|
   |虚函数|动态绑定|**改写**|调用函数时使用**派生类**版本|
<br>

### 运算符重载

- 前置`++`与后置`++`<br>前置`++`:没有参数,返回引用 `Type& operator ++();`
  ```C++
  class Example(){
      int value;
   public:
      Example(int v=0):value(v){}

      Example& operator++(){
         this->value++;
         return *this;
      }
  }
  ```
  后置`++`:有**哑元参数**`int`,返回**旧值拷贝** `Type operator++(int);`
   ```C++
   class Example(){
      int value;
   public:
      Example(int v=0):value(v){}

      Example operator++(int){
         Example temp=*this;
         this->value++;
         return temp;
      }
  }
  ```