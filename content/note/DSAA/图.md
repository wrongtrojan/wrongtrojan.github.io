+++
title = "图"
weight= 8
date = 2025-11-24
draft = false
tags=["ADT"]
+++
<!--more-->

## 图的术语及定义

>### 顶点 
>
>       又称节点，可以有自己名字称为键，也可以带有附加信息"有效载荷"

>### 边  
>
>       两顶点由边相连表示存在关系，既可以单向也可以双向
>
>       若图的所有边都单向称为有向图

>### 权重  
>
>       边可以带权重，表示从一个顶点到另一个顶点的成本

>### 路径
>       由边连接的顶点组成的序列，无权重路径长度是边数，有权重长度权重之和

>### 环
>       有向图中起点和终点同一个顶点的路径，没有环的图称为无环图
>
>       没有环的有向图称为有向无环图，简称DAG

>### 强连通
>
>       有向图从每一个顶点到其他顶点都存在一条路径

>### 弱连通
>
>        有向图不是强连通，但基础图(忽略方向)是联通的

>### 完全图
>
>        每一对顶点间都存在一条边的图

## 图模型

>       addVertex(vert) 向图中添加一个顶点实例
>
>       addEdge(fromVert, toVert) 向图中添加一条有向边连接顶点
>
>       addEdge(fromVert,toVert,weight) 向图中添加一条带权重的有向边连接顶点
>
>       getVertex(vertKey) 在图中找到名为vertkey的顶点
>
>       getVertices( ) 返回图中所有顶点
>
>       in(python中) 顶点存在时返回true，否则返回false

## 图的实现

>### 邻接矩阵(adjacency matrix)
>
>       实现图最简单的方式是使用二维矩阵，每一行每一列都表示图中一顶点
>
>       第v行和w列交叉的格子中的值表示从顶点v到顶点w的边的权重
>
>       如果图是稠密的(dense)\|E\|=Θ(\|V\|^2^)，则邻接矩阵是合适的表示方法
>
>       但在大部分应用中，图是稀疏的(sparse)

>### 邻接表(adjacency list)
>
>       对每一个顶点，我们使用一个表存放所有邻接的顶点
>
>       最左边的结构只是头单元(header cell)
>
>       这种方法空间需求为O(|E|+|V|)

## 宽度优先搜索(BFS)

>### 宽度优先
>
>       它会访问完所有与s相距k的顶点后再去访问与s相距k+1的顶点

>### 颜色标记
>
>       为记录进度，BFS会将顶点标记为白色、灰色或黑色
>
>       顶点没被访问时为白色，第一次被访问时标记为灰色，完成访问后标记为黑色
>
>       一旦顶点变为黑色，没有白色顶点与之相连

>### 队列处理
>
>       初次访问顶点入队，顶点被访问完全后出队
>
>       队列为空时所有可达顶点都被处理

>### 性能
>
>        O(|V|+|E|)

>### 应用
>
>        词梯问题

## 深度优先搜索(DFS)

>### 深度优先
>
>       DFS通过尽可能地探索分支来构建搜索树

>### 颜色标记
>
>       未访问的顶点是白色的，已访问的是灰色的

>### 栈处理
>
>       当递归做DFS遇到死路时必须回溯
>
>       通过栈回溯到上一个被访问节点

>### 通用深度优先搜索(General DFS)
>
>       前驱节点 构建深度优先搜索树，一次多颗称为深度优先森林
>
>       颜色标记 增加访问完成的黑色标记
>
>       时序记录 第一次访问与结束顶点访问的步数

> ### 性能
>
>       O(|V|+|E|)

> ### 应用
>
>       骑士周游问题

## 拓扑排序

>       对图调用深度优先搜索算法，计算每一个顶点的结束时间
>
>       基于结束时间，将顶点按照递减顺序存储在有序表中
>
>       将有序表作为拓扑排序结果返回

## 强连通单元

>       对图G调用深度优先搜索算法，计算每一个顶点的结束时间
>
>       对图G做转置得到G^T
>
>       对G^T调用深度优先搜索算法，按照结束时间的递减顺序访问顶点
>
>       得到的深度优先森林中的每一棵树都是一个强连通单元

## 最短路径问题

>### Dijkstra算法

>### Prim算法
